// This is the base rule script file for the AI response system for Expressive AI's who speak based on certain "Concepts"
// You can think of a concept as a high level state that the code is trying to convey, such as say hello, or say you're mad, etc.
//
// The format of this file is that there are five main types of commands:
// 1) #include "filename"	// This just causes the included scriptfile to be parsed and added to the database
// 2) enumeration:  this declares an enumerated type so that comparisons can be matched against the string versions of the type
// 3) response:  this specifies a response to issue.  A response consists of a weighted set of options and can recursively reference
//    other responses by name
// 4) criterion:  This is a match condition
// 5) rule:  a rule consists of one or more criteria and a response
//
// In general, the system is presented with a criteria set, which is a set of key value pairs generated by the game code and
//  various entity I/O and keyfields.  For instance, the following criteria set was created in a map with a train terminal 
// "speaker" entity wishing to fire random station announcements
//               concept = 'train_speaker' (weight 5.000000)		; the high level concept for the search request
//                   map = 'terminal_pa'							; the name of the map
//             classname = 'speaker'								; the classname and name of the "speaking" entity
//                  name = 'terminal_pa'
//                health = '10'										; the absolute health of the speaking entity
//            healthfrac = '0.000'									; the health fraction (health/maxhealth) of the speaking entity
//          playerhealth = '100'									; similar data related to the current player:
//      playerhealthfrac = '1.000'
//          playerweapon = 'none'									; the name of the weapon the player is carrying
//        playeractivity = 'ACT_WALK'								; animating activity of the player
//           playerspeed = '0.000'									; how fast the player is moving
//
// Based on such a criteria set, the system checks each rule against the set.  To do this, each criterion of the rule is
//  given a numeric score as follows:
// score = 0 if criteria doesn't match or, criterion weight * keyvaliue weight if it does match
// The final score for a rule is the sum of all of the scores of its criteria.  The best rule is the one with the highest
//  score.  Once a best rule is selected, then a response is looked up based on the response definitions and the engine is
//  asked to dispatch that response.
//
// The specific syntax for the various keywords is as follows:
//
// ENUMERATIONS:
//
// enumeration <enumerationname>
// { 
//		"key1" "value1"
//		"key2" "value2"
//		...etc.
//	}
//	The code and criteria refer to enumerations with square brackets and a double colon separator, e.g.:
//  [enumerationname::key1]
//
//
// RESPONSES:
//
// Single line: 
// response <responsegroupname> [nodelay | defaultdelay | delay interval ] [speakonce] [noscene] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] responsetype parameters
// Multiple lines
// response <responsegroupname>
// {
//		[permitrepeats]   ; optional parameter, by default we visit all responses in group before repeating any
//		[sequential]	  ; optional parameter, by default we randomly choose responses, but with this we walk through the list starting at the first and going to the last
//		[norepeat]		  ; Once we've run through all of the entries, disable the response group
//		responsetype1 parameters1 [nodelay | defaultdelay | delay interval ] [speakonce] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] [displayfirst] [ displaylast ] weight nnn
//		responsetype2 parameters2 [nodelay | defaultdelay | delay interval ] [speakonce] [odds nnn] [respeakdelay interval] [soundelvel "SNDLVL_xxx"] [displayfirst] [ displaylast ] weight nnn
//		etc.
// }
// Where: 
//   interval = "startnumber,endnumber" or "number" (e.g., "2.8,3.2" or "3.2")
//   responsetype =:
//     speak		; it's an entry in sounds.txt
//     sentence		; it's a sentence name from sentences.txt
//     scene		; it's a .vcd file
//     response		; it's a reference to another response group by name
//     print      ; print the text in developer 2 (for placeholder responses)
//   nodelay = an additional delay of 0 after speaking
//   defaultdelay = an additional delay of 2.8 to 3.2 seconds after speaking
//   delay interval = an additional delay based on a random sample from the interval after speaking
//   speakonce = don't use this response more than one time (default off)
//	 noscene = For an NPC, play the sound immediately using EmitSound, don't play it through the scene system. Good for playing sounds on dying or dead NPCs.
//   odds = if this response is selected, if odds < 100, then there is a chance that nothing will be said (default 100)
//	 respeakdelay = don't use this response again for at least this long (default 0)
//   soundlevel = use this soundlevel for the speak/sentence (default SNDLVL_TALKING)
//   weight = if there are multiple responses, this is a selection weighting so that certain responses are favored over others in the group (default 1)
//   displayfirst/displaylast : this should be the first/last item selected (ignores weight)
//
// CRITERIA:
//
// criterion <criterionname> <matchkey> <matchvalue> weight nnn required
// Where:
//  matchkey matches one of the criteria in the set as shown above
//  matchvalue is a string or number value or a range, the following are all valid:
//  "0"						; numeric match to value 0
//  "1"						; numeric match to value 1
//   "weapon_smg1"			; string match to weapon_smg1 string
//   "[npcstate::idle]"		; match enumeration by looking up numeric value
//   ">0"					; match if greater than zero
//   ">10,<=50"				; match if greater than ten and less than or equal to 50
//   ">0,<[npcstate::alert]"	; match if greater than zer and les then value of enumeration for alert
//   "!=0"					; match if not equal to zero
// weight = floating point weighting for score assuming criteria match (default value 1.0)
// required:  if a rule has one or more criteria with the required flag set, then if any such criteria
//  fail, the entire rule receives a score of zero
//
// RULE:
//
// rule <rulename>
// {
//    criteria name1 [name2 name3 etc.]
//    response responsegroupname [responsegroupname2 etc.]
//    [matchonce]					; optional parameter
//	  [ <matchkey > <matchvalue> weight nnn required ]
// }
// Where:
// criteria just lies one more more criterion names from above and response list one or more of the response
// names from above (usually just one)
// matchonce (off by default): means that the rule is deactivated after the first time it is matched
// Note that additional "unnamed" criteria can be specified inline in the rule using the same syntax
// as for defining a criterion, except for the criterion keyword and the criterion name keys
//
// Interaction with entity I/O system
// CBaseEntity contains an inputfunc called "DispatchResponse" which accepts a string which is a concept name
//  Thus, a game entity can fire this input on another entity with a concept string and a criteria set will
//  be generated and searched against the entities current response system rule set.
// Right now only the speaker entity and NPC_Talker derived NPCs have any response rules loaded
// In addition, map placed entities have up to three "context" keypairs that can be specified.
// They take the form:  "key:value" (key, single colon separator, value)
// When an entity with any such context keypairs is asked to dispatch a response, the keypairs are added to the
//  criteria set passed to the rule system.  Thus, map placed entities and triggers can specify their
//  own context keypairs and these can be hooked up to response rules to do map-specific and appropriate
//  responses
// In addition, entity I/O can be used to add, remove and clear any such context keypairs via the
//   AddContext, RemoveContext, and ClearContext input functions.
// AddContext takes a keypair of the "key:value" format, while RemoveContext take just the "key"
// ClearContext removes all context keypairs
// The game .dll code can enumerate context keypairs and change them via code based methods
//
// The player and the world have their context added with the string player or world as a prefix, e.g.:
//  "playerkey:value" or "worldkey:value" to differentiate world/player context from the context of the
//  responding entity.

// Base script
enumeration "NPCState"
{
	"None"		"0"
	"Idle"		"1"
	"Alert"		"2"
	"Combat"	"3"
	"Scripted"	"4"
	"PlayDead"	"5"
	"Dead"		"6"
}

response "NullResponse"

// Question / Answer concepts
criterion "ConceptTalkAnswer" "Concept" "TLK_ANSWER" required weight 1
criterion "ConceptTalkQuestion" "Concept" "TLK_QUESTION" required // weight 1 implied
criterion "ConceptTalkAnswerCitizen" "Concept" "TLK_ANSWER_CIT" required weight 1
criterion "ConceptTalkQuestionCitizen" "Concept" "TLK_QUESTION_CIT" required 
criterion "ConceptTalkAnswerVort" "Concept" "TLK_ANSWER_VORT" required weight 1
criterion "ConceptTalkQuestionVort" "Concept" "TLK_QUESTION_VORT" required 

// General concepts
criterion "ConceptTalkIdle" "Concept" "TLK_IDLE" required
criterion "ConceptTalkStare" "Concept" "TLK_STARE" required
criterion "ConceptTalkUse" "Concept" "TLK_USE" required
criterion "ConceptTalkStartFollow" "Concept" "TLK_STARTFOLLOW" required
criterion "ConceptTalkStopFollow" "Concept" "TLK_STOPFOLLOW" required
criterion "ConceptTalkStop" "Concept" "TLK_STOP" required
criterion "ConceptTalkNoShoot" "Concept" "TLK_NOSHOOT" required
criterion "ConceptTalkHello" "Concept" "TLK_HELLO" required
criterion "ConceptTalkPHello" "Concept" "TLK_PHELLO" required
criterion "ConceptTalkPIdle" "Concept" "TLK_PIDLE" required
criterion "ConceptTalkPQuestion" "Concept" "TLK_PQUESTION" required
criterion "ConceptTalkPlayerHurt1" "Concept" "TLK_PLHURT1" required
criterion "ConceptTalkPlayerHurt2" "Concept" "TLK_PLHURT2" required
criterion "ConceptTalkPlayerHurt3" "Concept" "TLK_PLHURT3" required
criterion "ConceptTalkPlayerPushed" "Concept" "TLK_PLPUSH" required
criterion "ConceptTalkSmell" "Concept" "TLK_SMELL" required
criterion "ConceptTalkWound" "Concept" "TLK_WOUND" required
criterion "ConceptTalkMortal" "Concept" "TLK_MORTAL" required
criterion "ConceptTalkDanger" "Concept" "TLK_DANGER" required
criterion "ConceptTalkResume" "Concept" "TLK_RESUME" required
criterion "ConceptTalkHeal" "Concept" "TLK_HEAL" required
criterion "ConceptTalkTourGuideStayPut" "Concept" "TLK_TGSTAYPUT" required
criterion "ConceptTalkTourGuideFind" "Concept" "TLK_TGFIND" required
criterion "ConceptTalkTourGuideSeek" "Concept" "TLK_TGSEEK" required
criterion "ConceptTalkTourGuideLostYou" "Concept" "TLK_TGLOSTYOU" required
criterion "ConceptTalkTourGuideCatchUp" "Concept" "TLK_TGCATCHUP" required
criterion "ConceptTalkTourGuideEndTour" "Concept" "TLK_TGENDTOUR" required
criterion "ConceptTalkSelected" "Concept" "TLK_SELECTED" required
criterion "ConceptTalkCommanded" "Concept" "TLK_COMMANDED" required
criterion "ConceptTalkCommandFailed" "Concept" "TLK_COMMAND_FAILED" required
criterion "ConceptTalkBetrayed" "Concept" "TLK_BETRAYED" required
criterion "ConceptTalkGiveAmmo" "Concept" "TLK_GIVEAMMO" required
criterion "ConceptTalkAllyKilled" "Concept" "TLK_ALLY_KILLED" required
criterion "ConceptSeeCombine" "Concept" "TLK_SEE_COMBINE" required
criterion "ConceptEnemyDead" "Concept" "TLK_ENEMY_DEAD" required
criterion "ConceptTalkWatchOut" "Concept" "TLK_WATCHOUT" required
criterion "ConceptTalkAttacking" "Concept" "TLK_ATTACKING" required
criterion "ConceptTalkDeath" "Concept" "TLK_DEATH" required
criterion "ConceptTalkHelpMe" "Concept" "TLK_HELP_ME" required
criterion "ConceptTalkPlayerPhysAttack" "Concept" "TLK_PLYR_PHYSATK" required
criterion "ConceptDissolveScream" "Concept" "TLK_DISSOLVESCREAM" required
criterion "ConceptElectrocuteScream" "Concept" "TLK_ELECTROCUTESCREAM" required
criterion "ConceptNewWeapon" "Concept" "TLK_NEWWEAPON" required
criterion "ConceptShot" "Concept" "TLK_SHOT" required
criterion "ConceptPlayerReload" "Concept" "TLK_PLRELOAD" required
criterion "ConceptPlayerDead" "Concept" "TLK_PLDEAD" required
criterion "ConceptHideAndReload" "Concept" "TLK_HIDEANDRELOAD" required
criterion "ConceptStartCombat" "Concept" "TLK_STARTCOMBAT" required
criterion "ConceptJoinPlayer" "Concept" "TLK_JOINPLAYER" required

// Lead behavior
criterion "ConceptLeadStart" "Concept" "TLK_LEAD_START" required			// Spoken once when the NPC first starts to lead the player
criterion "ConceptLeadWaitOver" "Concept" "TLK_LEAD_WAITOVER" required			// Spoken when the player arrives at an NPC waiting to lead the player
criterion "ConceptLeadAttractPlayer" "Concept" "TLK_LEAD_ATTRACTPLAYER" required	// Nag spoken by a NPC waiting to lead the player, trying to attract the player
criterion "ConceptLeadCatchup" "Concept" "TLK_LEAD_CATCHUP" required			// Spoken by the NPC when the player's lagging behind
criterion "ConceptLeadComingBack" "Concept" "TLK_LEAD_COMINGBACK" required		// Spoken when the NPC comes back to find a lost player
criterion "ConceptLeadRetrieve" "Concept" "TLK_LEAD_RETRIEVE" required			// Spoken when the NPC has come back to the player, and is now resuming the lead
criterion "ConceptLeadArrival" "Concept" "TLK_LEAD_ARRIVAL" required			// Spoken when the leading NPC reaches the target point
criterion "ConceptLeadSuccess" "Concept" "TLK_LEAD_SUCCESS" required			// Spoken when the player and the leading NPC have both reached the target point
criterion "ConceptLeadMissingWeapon" "Concept" "TLK_LEAD_MISSING_WEAPON" required	// Spoken when the NPC refuses to lead the player because he's missing a weapon

// Citizen responses
criterion "ConceptCRPlayerShotGunship" "Concept" "TLK_CITIZEN_RESPONSE_SHOT_GUNSHIP" required
criterion "ConceptCRPlayerKilledGunship" "Concept" "TLK_CITIZEN_RESPONSE_KILLEd_GUNSHIP" required
criterion "ConceptCRVitalNPCDied" "Concept" "TLK_VITALNPC_DIED" required

criterion "PlayerAlive" "PlayerHealth" ">0" required
criterion "PlayerDead" "PlayerHealth" "<=0" required
criterion "PlayerWounded" "PlayerHealthFrac"	">0,<=.5"
criterion "NPCAlive" "Health" ">0" required
criterion "NPCAlert" "NPCState" ">=[NPCState::Idle],<[NPCState::Alert]"
criterion "NPCIdle" "NPCState" "[NPCState::Idle]" required
criterion "PlayerNear" "distancetoplayer" "<500" required
criterion "SeePlayer" "seeplayer" "1" required
criterion "SeenByPlayer" "seenbyplayer" "1" required
criterion "NoRecentCombat" "timesincecombat" ">25" required

criterion "ShotInLeg" "shotloc" "leg" required weight 0
criterion "ShotInArm" "shotloc" "arm" required weight 0
criterion "ShotInGut" "shotloc" "gut" required weight 0

criterion "EnemyIsMortar" "enemy" "func_tankmortar" required

criterion "NotUsedVortResponse" "UsedVortResponse" "!=1" "required" weight 0
criterion "IsVortLabUseDisable" "VortLab_Enable" "0" weight 2 required

// Global states
criterion "IsGordonCriminal" "gordon_precriminal" "0" required
criterion "IsGordonPreCriminal" "gordon_precriminal" "1" required

criterion "IsMap_d3_c17_09" "map" "d3_c17_09" "required"

// Test rules
#include "talker/interjections.txt" 

#include "talker/npc_combine.txt"
#include "talker/response_k_lab.txt"
#include "talker/response_eli_lab.txt"
#include "talker/npc_vortigaunt.txt"
#include "talker/npc_citizen.txt"
#include "talker/npc_grigori.txt"
#include "talker/npc_barney.txt"
#include "talker/npc_alyx.txt"

