//====== Copyright 1996-2010, Valve Corporation, All rights reserved. =======
//
// Purpose: The file defines our Google Protocol Buffers which are used to define
//			proto script definition objects' structures.
//
//=============================================================================

// We care more about speed than code size
option optimize_for = SPEED;

// We don't use the service generation functionality
option cc_generic_services = false;


//
// STYLE NOTES:
//
// Use CamelCase CMsgMyMessageName style names for messages.
//
// Use lowercase _ delimited names like my_steam_id for field names, this is non-standard for Steam,
// but plays nice with the Google formatted code generation.
//
// Try not to use required fields ever. Only do so if you are really really sure you'll never want them removed.
// Optional should be preffered as it will make versioning easier and cleaner in the future if someone refactors
// your message and wants to remove or rename fields.
//
// Use fixed64 for JobId_t, GID_t, or SteamID.  This is appropriate for any field that is normally
// going to be larger than 2^56.  Otherwise use int64 for 64 bit values that are frequently smaller
// than 2^56 as it will safe space on the wire in those cases.
//
// Similar to fixed64, use fixed32 for RTime32 or other 32 bit values that are frequently larger than
// 2^28.  It will safe space in those cases, otherwise use int32 which will safe space for smaller values.
// An exception to this rule for RTime32 is if the value will frequently be zero rather than set to an actual
// time.
//
// Note: to make something a key field, list it like so:
// optional	uint32		account_id = 1 [ (key_field) = true ];


import "google/protobuf/descriptor.proto";

extend google.protobuf.MessageOptions
{
    optional bool start_expanded = 80000 [ default = true ];
}

extend google.protobuf.FieldOptions
{
	optional ProtoDefTypes valid_type = 70000;
	optional bool editable = 70001 [ default = true ];
	optional bool localized = 70002 [ default = false ];
	optional bool do_not_inherit = 70003 [ default = false ];
	optional string display_name = 70004;
	optional string comment = 70005;
	optional uint32	max_count = 70007;
	optional bool allow_add = 70008 [ default = true ];
	optional bool allow_delete = 70009 [ default = true ];
	optional string panel_class_override = 70010;
	optional string message_inherhitance_key_field_name = 70011; // If the empty string, just append.  If not, try to find any repeated fields
																// in the derived message that has a matching key field
	optional bool inherit_reference_variables = 70012 [ default = false ];
	optional bool self_inherit_only = 70013 [ default = false ];
	optional EVarFieldType var_field_type = 70014 [ default = VAR_TYPE_INVALID ];
	optional bool merging_key_field = 70015 [ default = false ];
}

enum LogicalOperation
{
	AND = 0;
	OR = 1;
	NOT = 2;
};


// A reference to a field that might be within a nested message
message CMsgFieldID
{
	// A reference to a field
	message CMsgField
	{
		optional uint32 field_number = 1;
		optional uint32 repeated_index = 2; // This is ignored for non-repeated fields
	}

	repeated CMsgField field = 1; // Starting in the defining message body scope
}

enum EValueDefinitionSource
{
	REFERENCE_DEFINES = 0;
	PARENT_DEFINES = 1;
	THIS_DEFINES = 2;
	VARIABLE_DEFINES = 3;
	NOT_DEFINED = 4; // The default value is used
};

message CMsgUniversalFieldID
{
	optional EValueDefinitionSource	source_type		= 1; // Which type is defining us
	optional CMsgProtoDefID			defining_obj_id	= 2; // Which object defined the value
	optional CMsgFieldID			field_id		= 3; // From which field ID within the object
}

message CMsgVariableDefinition
{
	optional string			name		= 1 [ (merging_key_field) = true ];
	optional bool			inherit		= 2 [ default = true ];
	optional string			value		= 3;
}

message CMsgProtoDefHeader
{
	required uint32						defindex				= 1 [ (editable) = false,
																	  (self_inherit_only) = true,
																	  (display_name) = "Defindex",
																	  (comment) = "Autogenerated" ];

	optional string						name					= 2 [ (self_inherit_only)	= true,
																	  (display_name)		= "Name",
																	  (comment)				= "Name to show in the editor" ];

	repeated CMsgProtoDefID				prefabs					= 3 [ (self_inherit_only)	= true,
																	  (display_name)		= "Prefab",
																	  (panel_class_override) = "CPrefabFieldEditingPanel",
																	  (comment)				= "Inherit the values of these definitions, in order from top to bottom." ];

	repeated string						tags					= 4 [ (display_name)		= "Tags",
																	  (comment)				= "Strings used to describe this definition while searching.  ie. 'class', 'shotgun', 'easy'" ];

	optional bool						prefab_only				= 5 [ (self_inherit_only)	= true,
																	  default				= false,
																	  (display_name)		= "Pure Prefab",
																	  (comment)				= "If true, this is only a prefab and will not be made into an object" ];

	repeated CMsgVariableDefinition		variables				= 6 [ (message_inherhitance_key_field_name) = "name",
																	  (display_name)		= "Variables",
																	  (comment)				= "Variable value definitions" ];


}

// Add to the end and do not re-usereorder or fill gaps
enum ProtoDefTypes
{
	DEF_TYPE_QUEST_MAP_NODE = 0;
	DEF_TYPE_QUEST_THEME = 2;
	DEF_TYPE_QUEST_MAP_REGION = 3;
	DEF_TYPE_QUEST = 4;
	DEF_TYPE_QUEST_OBJECTIVE = 5;
	DEF_TYPE_PAINTKIT_VARIABLES = 6;
	DEF_TYPE_PAINTKIT_OPERATION = 7;
	DEF_TYPE_PAINTKIT_ITEM_DEFINITION = 8;
	DEF_TYPE_PAINTKIT_DEFINITION = 9;
	DEF_TYPE_HEADER_ONLY = 10;
	DEF_TYPE_QUEST_MAP_STORE_ITEM = 11;
	DEF_TYPE_QUEST_MAP_STAR_TYPE = 12;
};

message CMsgValidTypes
{
	repeated ProtoDefTypes types = 1;
}

message CMsgProtoDefID
{
	optional uint32 defindex = 1;
	optional ProtoDefTypes type = 2;

	oneof instance
	{
		CMsgQuestMapNodeDef			instance_def_type_quest_map_node = 3;
		CMsgQuestTheme				instance_def_type_quest_theme = 5;
		CMsgQuestMapRegionDef		instance_def_type_quest_map_region = 6;
		CMsgQuestDef				instance_def_type_quest = 7;
		CMsgQuestObjectiveDef		instance_def_type_quest_objective = 8;
		CMsgPaintKit_Variables		instance_def_type_paintkit_variables = 9;
		CMsgPaintKit_Operation		instance_def_type_paintkit_operation = 10;
		CMsgPaintKit_ItemDefinition	instance_def_type_paintkit_item_definition = 11;
		CMsgPaintKit_Definition		instance_def_type_paintkit_definition = 12;
		CMsgHeaderOnly				instance_def_type_header_only = 13;
	}
}

enum EQuestPoints
{
	QUEST_POINTS_NOVICE = 0;
	QUEST_POINTS_ADVANCED = 1;
	QUEST_POINTS_EXPERT = 2;
}

message CMsgQuestObjectiveDef
{
	enum ETF2GameModes
	{
		kGameCategory_Escort = 0;
		kGameCategory_CTF = 1;
		kGameCategory_AttackDefense = 2;
		kGameCategory_Koth = 3;
		kGameCategory_CP = 4;
		kGameCategory_EscortRace = 5;
		kGameCategory_EventMix = 6;
		kGameCategory_SD = 7;
		kGameCategory_Quickplay = 8;
		kGameCategory_Event247 = 9;
		kGameCategory_Arena = 10;
		kGameCategory_RobotDestruction = 11;
		kGameCategory_Powerup = 12;
		kGameCategory_Featured = 13;
		kGameCategory_Passtime = 14;
		kGameCategory_Community_Update = 15;
		kGameCategory_Misc = 16;
		kGameCategory_Competitive_6v6 = 17;
		kGameCategory_Other = 18;
		kGameCategory_Halloween = 19;
	};

	enum ETF2Conditions
	{
		TF_COND_AIMING = 0;
		TF_COND_ZOOMED = 1;
		TF_COND_DISGUISING = 2;
		TF_COND_DISGUISED = 3;
		TF_COND_STEALTHED = 4;
		TF_COND_INVULNERABLE = 5;
		TF_COND_TELEPORTED = 6;
		TF_COND_TAUNTING = 7;
		TF_COND_INVULNERABLE_WEARINGOFF = 8;
		TF_COND_STEALTHED_BLINK = 9;
		TF_COND_SELECTED_TO_TELEPORT = 10;
		TF_COND_CRITBOOSTED = 11;
		TF_COND_TMPDAMAGEBONUS = 12;
		TF_COND_FEIGN_DEATH = 13;
		TF_COND_PHASE = 14;
		TF_COND_STUNNED = 15;
		TF_COND_OFFENSEBUFF = 16;
		TF_COND_SHIELD_CHARGE = 17;
		TF_COND_DEMO_BUFF = 18;
		TF_COND_ENERGY_BUFF = 19;
		TF_COND_RADIUSHEAL = 20;
		TF_COND_HEALTH_BUFF = 21;
		TF_COND_BURNING = 22;
		TF_COND_HEALTH_OVERHEALED = 23;
		TF_COND_URINE = 24;
		TF_COND_BLEEDING = 25;
		TF_COND_DEFENSEBUFF = 26;
		TF_COND_MAD_MILK = 27;
		TF_COND_MEGAHEAL = 28;
		TF_COND_REGENONDAMAGEBUFF = 29;
		TF_COND_MARKEDFORDEATH = 30;
		TF_COND_NOHEALINGDAMAGEBUFF = 31;
		TF_COND_SPEED_BOOST = 32;
		TF_COND_CRITBOOSTED_PUMPKIN = 33;
		TF_COND_CRITBOOSTED_USER_BUFF = 34;
		TF_COND_CRITBOOSTED_DEMO_CHARGE = 35;
		TF_COND_SODAPOPPER_HYPE = 36;
		TF_COND_CRITBOOSTED_FIRST_BLOOD = 37;
		TF_COND_CRITBOOSTED_BONUS_TIME = 38;
		TF_COND_CRITBOOSTED_CTF_CAPTURE = 39;
		TF_COND_CRITBOOSTED_ON_KILL = 40;
		TF_COND_CANNOT_SWITCH_FROM_MELEE = 41;
		TF_COND_DEFENSEBUFF_NO_CRIT_BLOCK = 42;
		TF_COND_REPROGRAMMED = 43;
		TF_COND_CRITBOOSTED_RAGE_BUFF = 44;
		TF_COND_DEFENSEBUFF_HIGH = 45;
		TF_COND_SNIPERCHARGE_RAGE_BUFF = 46;
		TF_COND_DISGUISE_WEARINGOFF = 47;
		TF_COND_MARKEDFORDEATH_SILENT = 48;
		TF_COND_DISGUISED_AS_DISPENSER = 49;
		TF_COND_SAPPED = 50;
		TF_COND_INVULNERABLE_HIDE_UNLESS_DAMAGED = 51;
		TF_COND_INVULNERABLE_USER_BUFF = 52;
		TF_COND_HALLOWEEN_BOMB_HEAD = 53;
		TF_COND_HALLOWEEN_THRILLER = 54;
		TF_COND_RADIUSHEAL_ON_DAMAGE = 55;
		TF_COND_CRITBOOSTED_CARD_EFFECT = 56;
		TF_COND_INVULNERABLE_CARD_EFFECT = 57;
		TF_COND_MEDIGUN_UBER_BULLET_RESIST = 58;
		TF_COND_MEDIGUN_UBER_BLAST_RESIST = 59;
		TF_COND_MEDIGUN_UBER_FIRE_RESIST = 60;
		TF_COND_MEDIGUN_SMALL_BULLET_RESIST = 61;
		TF_COND_MEDIGUN_SMALL_BLAST_RESIST = 62;
		TF_COND_MEDIGUN_SMALL_FIRE_RESIST = 63;
		TF_COND_STEALTHED_USER_BUFF = 64;
		TF_COND_MEDIGUN_DEBUFF = 65;
		TF_COND_STEALTHED_USER_BUFF_FADING = 66;
		TF_COND_BULLET_IMMUNE = 67;
		TF_COND_BLAST_IMMUNE = 68;
		TF_COND_FIRE_IMMUNE = 69;
		TF_COND_PREVENT_DEATH = 70;
		TF_COND_MVM_BOT_STUN_RADIOWAVE = 71;
		TF_COND_HALLOWEEN_SPEED_BOOST = 72;
		TF_COND_HALLOWEEN_QUICK_HEAL = 73;
		TF_COND_HALLOWEEN_GIANT = 74;
		TF_COND_HALLOWEEN_TINY = 75;
		TF_COND_HALLOWEEN_IN_HELL = 76;
		TF_COND_HALLOWEEN_GHOST_MODE = 77;
		TF_COND_MINICRITBOOSTED_ON_KILL = 78;
		TF_COND_OBSCURED_SMOKE = 79;
		TF_COND_PARACHUTE_ACTIVE = 80;
		TF_COND_BLASTJUMPING = 81;
		TF_COND_HALLOWEEN_KART = 82;
		TF_COND_HALLOWEEN_KART_DASH = 83;
		TF_COND_BALLOON_HEAD = 84;
		TF_COND_MELEE_ONLY = 85;
		TF_COND_SWIMMING_CURSE = 86;
		TF_COND_FREEZE_INPUT = 87;
		TF_COND_HALLOWEEN_KART_CAGE = 88;
		TF_COND_DONOTUSE_0 = 89;
		TF_COND_RUNE_STRENGTH = 90;
		TF_COND_RUNE_HASTE = 91;
		TF_COND_RUNE_REGEN = 92;
		TF_COND_RUNE_RESIST = 93;
		TF_COND_RUNE_VAMPIRE = 94;
		TF_COND_RUNE_REFLECT = 95;
		TF_COND_RUNE_PRECISION = 96;
		TF_COND_RUNE_AGILITY = 97;
		TF_COND_GRAPPLINGHOOK = 98;
		TF_COND_GRAPPLINGHOOK_SAFEFALL = 99;
		TF_COND_GRAPPLINGHOOK_LATCHED = 100;
		TF_COND_GRAPPLINGHOOK_BLEEDING = 101;
		TF_COND_AFTERBURN_IMMUNE = 102;
		TF_COND_RUNE_KNOCKOUT = 103;
		TF_COND_RUNE_IMBALANCE = 104;
		TF_COND_CRITBOOSTED_RUNE_TEMP = 105;
		TF_COND_PASSTIME_INTERCEPTION = 106;
		TF_COND_SWIMMING_NO_EFFECTS = 107;
		TF_COND_PURGATORY = 108;
		TF_COND_RUNE_KING = 109;
		TF_COND_RUNE_PLAGUE = 110;
		TF_COND_RUNE_SUPERNOVA = 111;
		TF_COND_PLAGUE = 112;
		TF_COND_KING_BUFFED = 113;
		TF_COND_TEAM_GLOWS = 114;
		TF_COND_KNOCKED_INTO_AIR = 115;
		TF_COND_COMPETITIVE_WINNER = 116;
		TF_COND_COMPETITIVE_LOSER = 117;
		TF_COND_HEALING_DEBUFF = 118;
		TF_COND_PASSTIME_PENALTY_DEBUFF = 119;
		TF_COND_PARACHUTE_DEPLOYED = 120;

		TF_COND_NO_COMBAT_SPEED_BOOST = 121;
		TF_COND_TRANQ_SPY_BOOST = 122;
		TF_COND_TRANQ_MARKED = 123;
	//	TF_COND_SPACE_GRAVITY = 124;
	//	TF_COND_SELF_CONC = 125;
		TF_COND_ROCKETPACK = 126;
		TF_COND_ROCKETPACK_PASSENGER = 127;
		TF_COND_STEALTHED_PHASE = 128;
		TF_COND_CLIP_OVERLOAD = 129;
		TF_COND_SPY_CLASS_STEAL = 130;
		TF_COND_GAS = 131;
	};

	enum ETF2Team
	{
		TF_TEAM_RED = 2;
		TF_TEAM_BLUE = 3;
	};

	required	CMsgProtoDefHeader	header				= 1;
	optional	string				loc_desctoken		= 2 [ (localized) = true ];
	optional	uint32				points				= 3;
	optional	uint32				conditions_defindex = 5;
	repeated	string				map = 8				[ (display_name)	= "Maps Modifier"
														, (comment)			= "If set, the player must be on one of the listed maps to get credit." ];
	repeated	ETF2GameModes		game_mode = 9		[ (display_name)	= "Game Mode Modifier"
														, (comment)			= "If set, the player must be in one of the listed game modes to get credit." ];
	optional	ETF2Team			team = 10			[ (display_name)	= "Team Modifier"
														, (comment)			= "If set, the player must be on the specified team to get credit." ];

	repeated	CMsgVarField		condition_vars		= 11 [ (var_field_type) = VAR_TYPE_STRING, (display_name) = "Objective Vars" ];
	repeated	CMsgVarField		classes_vars		= 12 [ (var_field_type) = VAR_TYPE_STRING, (display_name) = "Class Modifier" ];
	repeated	ETF2Conditions		conditions			= 13 [ (display_name) = "Required Conds" ];
	optional	LogicalOperation	condition_logic		= 14 [ (display_name) = "Condition Logic", (comment) = "What kind of logic to use when evaluating the player's conditions." ];
	repeated	string				item_name			= 15 [ (display_name) = "Required equipped item", (comment) = "Require that this item be equipped in any slot." ];
	optional	LogicalOperation	item_logic			= 16 [ (display_name) = "Item logic", (comment) = "What kind of logic to use when evaluating the player's items." ];
	optional	uint32				jump_state			= 17 [ (display_name) = "Jump logic", (comment) = "What state of jumping the player needs to be in." ];
}

message CMsgQuestDef
{
	message MMCriteria
	{
		optional	string	group_name = 1;
		optional	string	category_name = 2;
		optional	string	map_name = 3;
	}

	message ObjectiveInstance
	{
		optional CMsgProtoDefID objective = 1 [ (valid_type) = DEF_TYPE_QUEST_OBJECTIVE ];
		optional EQuestPoints	point_type = 2;
		optional uint32			point_value = 3 [ (display_name) = "Points Override", (comment) = "Override value for the point value of the objective.  If not set, uses the objective's point value" ];
	}

	required	CMsgProtoDefHeader	header				= 1;
	optional	uint32				max_points_0		= 2;
	optional	uint32				max_points_1		= 3;
	optional	uint32				max_points_2		= 4;
	optional	string				name_loctoken		= 5 [ (localized) = true ];
	optional	string				operation			= 7;
	optional	MMCriteria			mm_criteria			= 8;
	optional	string				node_image			= 12 [ (display_name) = "Node Image", (comment) = "Filename of the image to show on the node view" ];
	optional	string				icon_image			= 13 [ (display_name) = "Node Icon", (comment) = "Which icon to show on the map" ];
	optional	CMsgProtoDefID		theme				= 14 [ (valid_type) = DEF_TYPE_QUEST_THEME ];	// Which theme to use
	repeated	string				loaner_names		= 15 [ (display_name) = "Loaners", (comment) = "Names of items to give as loaners" ];
	repeated	ObjectiveInstance	objectives			= 16;
	repeated	string				map					= 17 [ (display_name)	= "Maps Modifier", (comment) = "If set, the player must be on one of the listed maps to get credit." ];
}

message CMsgQuestMapStoreItem
{
	required	CMsgProtoDefHeader	header					= 1;
	optional	string				item_name				= 2;	// Item name
	optional	string				reward_lootlist_name	= 6 [ (display_name) = "Reward Lootlist", (comment) = "The name of the lootlist to roll as a reward" ];
	optional	CMsgVarField		price					= 3 [ (var_field_type) = VAR_TYPE_SINT32 ];
	optional	uint32				purchase_limit			= 4 [ (display_name) = "Purchase Limit", (comment) = "How many times this reward can be purchased" ]; 
	optional	uint32				sort_group				= 5 [ (display_name) = "Sort group", (comment) = "Sort by this group, then alhpabetically" ];
}

message CMsgQuestMapRegionDef
{
	message RegionLink
	{
		required CMsgProtoDefID		target_region_defid	= 1 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION ];	// Which region this link references
		optional uint32				xpos				= 2;
		optional uint32				ypos				= 3;
	}

	required CMsgProtoDefHeader header		= 1;
	optional string				name		= 2 [ (localized) = true ];
	optional string				resfile		= 3;
	repeated RegionLink			links		= 4;
	optional CMsgProtoDefID		return_link = 5 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION, (display_name) = "Return Link", (comment) = "Which link we go to when right-clicking in this region" ];
	optional float				radio_freq	= 6 [ (display_name) = "Radio Freq.", (comment) = "Where the radio tuner goes on the CYOA PDA when this region is selection" ];
	optional float				zoom_scale	= 7 [ (display_name) = "Zoom Scale", (comment) = "How zoomed in this panel should be.  Affects the scale of the map grid lines and node link dashed lines" ];
	optional CMsgProtoDefID		star_type  = 8 [ (valid_type) = DEF_TYPE_QUEST_MAP_STAR_TYPE, (display_name) = "Star Type", (comment) = "What stars (if any) the nodes within use to unlock" ];
}

enum EVarFieldType
{
	VAR_TYPE_INVALID = 1;
	VAR_TYPE_FLOAT	= 2;
	VAR_TYPE_DOUBLE	= 3;
	VAR_TYPE_UINT32	= 4;
	VAR_TYPE_UINT64	= 5;
	VAR_TYPE_SINT32	= 6;
	VAR_TYPE_SINT64	= 7;
	VAR_TYPE_BOOL	= 8;
	VAR_TYPE_STRING	= 9;
}

message CMsgVarField
{
	optional string variable = 1 [ (merging_key_field) = true ];

	oneof value
	{
		float	float	= 2;
		double	double	= 3;
		uint32	uint32	= 4;
		uint64	uint64	= 5;
		sint32	sint32	= 6;
		sint64	sint64	= 7;
		bool	bool	= 8;
		string	string	= 9;
	}
}

enum ENodeCashReward
{
	CASH_REWARD_NONE = 1;
	CASH_REWARD_SMALL = 2;
	CASH_REWARD_MEDIUM = 3;
	CASH_REWARD_LARGE = 4;
}

message CMsgQuestMapStarType
{
	required	CMsgProtoDefHeader	header		= 1;
	optional	string				name		= 2 [ (localized) = true, (display_name) = "Type Name" ];
}

message CMsgQuestMapNodeDef
{
	required	CMsgProtoDefHeader			header				= 1;
	optional	string						name_loctoken		= 4 [ (localized) = true, (display_name) = "Node Name", (comment) = "The name of this node" ];
	optional	float						x_pos				= 6 [ (display_name) = "Map X Pos", (comment) = "X position on the quest map" ];
	optional	float						y_pos				= 7 [ (display_name) = "Map Y Pos", (comment) = "Y position on the quest map" ];
	optional	CMsgQuestMapNodeCondition	condition			= 9 [ (display_name) = "Conditions", (comment) = "Logic to unlock this node. Can be nested with logic" ];
	optional	CMsgProtoDefID				owning_region		= 10 [ (valid_type) = DEF_TYPE_QUEST_MAP_REGION , (display_name) = "Region", (comment) = "Which region in the map this node shows up in" ];
	repeated	CMsgProtoDefID				quest_options		= 11 [ (valid_type) = DEF_TYPE_QUEST, (display_name) = "Offered Quests", (comment) = "Which quests this node offers.", (max_count) = 3 ];
	optional	string						associated_operation= 16 [ (display_name) = "Associated Operation", (comment) = "Operation this node is associated with" ];
	optional	string						reward_item_name	= 18 [ (display_name) = "Reward Item", (comment) = "The name of an item to give as a reward" ];
	optional	string						reward_lootlist_name= 22 [ (display_name) = "Reward Lootlist", (comment) = "The name of the lootlist to roll as a reward" ];
	optional	ENodeCashReward				cash_reward			= 19 [ (display_name) = "Cash Reward", (comment) = "How much cash to give when completing the primary objective" ];
	optional	CMsgProtoDefID				star_type			= 20 [ (valid_type) = DEF_TYPE_QUEST_MAP_STAR_TYPE, (display_name) = "Star Type", (comment) = "Which type of star this node uses" ];
	optional	uint32						stars_to_unlock		= 21 [ default = 1, (display_name) = "Stars to Unlock", (comment) = "Numbers of stars it costs to unlock" ];
}

// template variables that don't change for an item
message CMsgPaintKit_Variables
{
	required	CMsgProtoDefHeader	header			=	1;
}

message CMsgPaintKit_Operation_TextureStage
{
	optional	CMsgVarField	texture			=	1	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseStringFromKV,
	optional	CMsgVarField	texture_red		=	2	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseStringFromKV,
	optional	CMsgVarField	texture_blue	=	3	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseStringFromKV,
	optional	CMsgVarField	adjust_black	=	4	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField	adjust_offset	=	5	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField	adjust_gamma	=	6	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseInverseRangeFromKV,
	optional	CMsgVarField	rotation		=	7	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	translate_u		=	8	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	translate_v		=	9	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	scale_uv		=	10	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	flip_u			=	11	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseBoolFromKV,
	optional	CMsgVarField	flip_v			=	12	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseBoolFromKV,
}

message CMsgPaintKit_Operation_CombineStage
{
	optional	CMsgVarField	adjust_black	=	1	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField	adjust_offset	=	2	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField	adjust_gamma	=	3	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseInverseRangeFromKV,
	optional	CMsgVarField	rotation		=	4	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	translate_u		=	5	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	translate_v		=	6	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	scale_uv		=	7	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeFromKV,
	optional	CMsgVarField	flip_u			=	8	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseBoolFromKV,
	optional	CMsgVarField	flip_v			=	9	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseBoolFromKV,

	repeated	CMsgPaintKit_OperationNode	operation_node	=	11;
}

message CMsgPaintKit_Operation_SelectStage
{
	optional	CMsgVarField	groups			=	1	[ (var_field_type) = VAR_TYPE_STRING ];						//	ParseStringFromKV,
	repeated	CMsgVarField	select			=	2	[ (var_field_type) = VAR_TYPE_STRING, (max_count) = 16 ];	//	ParseVectorFromKV< int, cMaxSelectors >,
}

message CMsgPaintKit_Operation_Sticker
{
	optional	CMsgVarField	base			=	1	[ (var_field_type) = VAR_TYPE_STRING, (comment) = "Name of the base file for the sticker (the albedo)" ];
	optional	CMsgVarField	weight			=	2	[ (var_field_type) = VAR_TYPE_STRING, (comment) = "Random likelihood this one is to be selected" ];
	optional	CMsgVarField	spec			=	3	[ (var_field_type) = VAR_TYPE_STRING, (comment) = "Name of the specular file for the sticker, or if blank we will assume it is baseFilename + _spec + baseExtension" ];
}

message CMsgPaintKit_Operation_StickerStage
{
	repeated	CMsgPaintKit_Operation_Sticker	sticker			=	1;	//	ParseVectorFromKV< Sticker_t >,
	optional	CMsgVarField					dest_tl			=	2	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseSettable< Vector2D >,
	optional	CMsgVarField					dest_tr			=	3	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseSettable< Vector2D >,
	optional	CMsgVarField					dest_bl			=	4	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseSettable< Vector2D >,
	optional	CMsgVarField					adjust_black	=	5	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField					adjust_offset	=	6	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseRangeThenDivideBy<255>,
	optional	CMsgVarField					adjust_gamma	=	7	[ (var_field_type) = VAR_TYPE_STRING ];	//	ParseInverseRangeFromKV,

	repeated	CMsgPaintKit_OperationNode		operation_node	=	9;
}

message CMsgPaintKit_OperationStage
{
	oneof stage
	{
		CMsgPaintKit_Operation_TextureStage		texture_lookup			= 1;
		CMsgPaintKit_Operation_CombineStage		combine_add				= 2;
		CMsgPaintKit_Operation_CombineStage		combine_lerp			= 3;
		CMsgPaintKit_Operation_CombineStage		combine_multiply		= 4;
		CMsgPaintKit_Operation_SelectStage		select					= 5;
		CMsgPaintKit_Operation_StickerStage		apply_sticker			= 6;
	}
}

message CMsgPaintKit_OperationNode
{
	oneof node
	{
		CMsgPaintKit_OperationStage				stage					= 1;
		CMsgProtoDefID							operation_template		= 2 [ (valid_type) =  DEF_TYPE_PAINTKIT_OPERATION, (inherit_reference_variables) = true ];
	}
}

message CMsgPaintKit_Operation
{
	required	CMsgProtoDefHeader				header			= 1;
	repeated	CMsgPaintKit_OperationNode		operation_node	= 2;
}

// paintkit item def
message CMsgPaintKit_ItemDefinition
{
	// paintkit def is a combination of variables and operations
	message Definition
	{
		optional	CMsgProtoDefID		operation_template	=	1 [ (valid_type) = DEF_TYPE_PAINTKIT_OPERATION ];
		repeated	CMsgVarField		variable			=	2 [ (allow_add) = false, (allow_delete) = false, (var_field_type) = VAR_TYPE_STRING ];
	}

	required	CMsgProtoDefHeader	header					=	1;
	required	uint32				item_definition_index	=	2;
	optional	CMsgProtoDefID		variable_template		=	3 [ (valid_type) =  DEF_TYPE_PAINTKIT_VARIABLES, (inherit_reference_variables) = true ];
	repeated	Definition			definition				=	4 [ (max_count) = 5 ];
}

message CMsgPaintKit_Definition
{
	message Item
	{
		option (start_expanded) = false;

		required	CMsgProtoDefID			item_definition_template	= 1	[ (valid_type) =  DEF_TYPE_PAINTKIT_ITEM_DEFINITION , (panel_class_override) = "CPaintKitDefIdFieldProtoEditorField" ];

		message ItemData
		{
			optional	bool					can_apply_paintkit			= 2 [ default = true ];
			optional	string					material_override			= 3;
			repeated	CMsgVarField			variable					= 4 [ (allow_add) = false, (allow_delete) = false, (var_field_type) = VAR_TYPE_STRING ];
		}

		optional ItemData data = 5;
	}

	required	CMsgProtoDefHeader			header				= 1;
	optional	string						loc_desctoken		= 2	[ (localized) = true ];
	optional	CMsgProtoDefID				operation_template	= 3 [ (inherit_reference_variables) = true, (valid_type) = DEF_TYPE_PAINTKIT_OPERATION , (comment) = "operation template which all items in the list will use unless there's operation_template specified in an item_definition" ];
	optional	bool						has_team_textures	= 4;

	// this is only for OLD paintkit
	repeated	Item						item				= 5;

	// add paintkit weapons here
	optional	Item						paintkit_tool       = 6;

	//stock paintkit weapons
	optional	Item						flamethrower        = 7;
	optional	Item						grenadelauncher     = 8;
	optional	Item						knife               = 9;
	optional	Item						medigun             = 10;
	optional	Item						minigun             = 11;
	optional	Item						pistol              = 12;
	optional	Item						revolver            = 13;
	optional	Item						rocketlauncher      = 14;
	optional	Item						scattergun          = 15;
	optional	Item						shotgun             = 16;
	optional	Item						smg                 = 17;
	optional	Item						sniperrifle         = 18;
	optional	Item						stickybomb_launcher = 19;
	optional	Item						ubersaw             = 20;
	optional	Item						wrench              = 21;
	//workshop paintkit weapons
	optional	Item						amputator           = 22;
	optional	Item						atom_launcher       = 23;
	optional	Item						back_scratcher      = 24;
	optional	Item						battleaxe           = 25;
	optional	Item						bazaar_sniper       = 26;
	optional	Item						blackbox            = 27;
	optional	Item						claidheamohmor      = 28;
	optional	Item						crusaders_crossbow  = 29;
	optional	Item						degreaser           = 30;
	optional	Item						demo_cannon         = 31;
	optional	Item						demo_sultan_sword   = 32;
	optional	Item						detonator           = 33;
	optional	Item						gatling_gun         = 34;
	optional	Item						holymackerel        = 35;
	optional	Item						jag                 = 36;
	optional	Item						lochnload           = 37;
	optional	Item						powerjack           = 38;
	optional	Item						quadball            = 39;
	optional	Item						reserve_shooter     = 40;
	optional	Item						riding_crop         = 41;
	optional	Item						russian_riot        = 42;
	optional	Item						scimitar            = 43;
	optional	Item						scorch_shot         = 44;
	optional	Item						shortstop           = 45;
	optional	Item						soda_popper         = 46;
	optional	Item						tele_shotgun        = 47;
	optional	Item						tomislav            = 48;
	optional	Item						trenchgun           = 49;
	optional	Item						winger_pistol       = 50;
}

message CMsgQuestTheme
{
	message WeightedString
	{
		optional string string = 1;
		optional uint32 weight = 2;
	}

	message WeightedStringSet
	{
		repeated WeightedString weighted_strings = 1;
	}

	required	CMsgProtoDefHeader	header	= 1;

	optional string notification_res = 2;
	optional string quest_item_res = 3;
	optional string in_game_tracker_res = 4;

	// Sounds
	repeated WeightedStringSet give_sounds = 5;
	repeated WeightedStringSet complete_sounds = 6;
	repeated WeightedStringSet fully_complete_sounds = 7;
	optional string reward_sound = 8;
	optional string discard_sound = 9;
	optional string reveal_sound = 10;
}

message CMsgQuestMapNodeCondition_NodeState
{
	optional uint32 bonus_objectives_required = 1 [ default = 0, (display_name) = "Bonus Required", (comment) = "Number of bonus objectives required, on top of the primary objective" ];
	required CMsgProtoDefID				target_node_defid	= 2 [ (valid_type) = DEF_TYPE_QUEST_MAP_NODE, (display_name) = "Target Node", (comment) = "Which node is required to have the above number of medals" ];	
}

message CMsgQuestMapNodeCondition_Logic
{
	required LogicalOperation	operation		= 1 [ (display_name) = "Logic", (comment) = "Logical operation" ];
	repeated CMsgQuestMapNodeCondition sub_conditions	= 2 [ (display_name) = "Operands", (comment) = "Definitions to use in the logical operation" ];
}

message CMsgQuestMapNodeCondition
{
	oneof operation
	{
		CMsgQuestMapNodeCondition_NodeState node_state = 1 [ (display_name) = "Node State Condition", (comment) = "Returns true if a specific node has a required number of medals" ];
		CMsgQuestMapNodeCondition_Logic logical = 2 [ (display_name) = "Logical Condition", (comment) = "Performs a specified logical operation to all sub conditions" ];
	}
}

message CMsgHeaderOnly
{
	required	CMsgProtoDefHeader	header	= 1;
}

// End of File
