import sys
import os

def RegisterModules(settings):
    ''' Finds and creates the lists of modules to be parsed. '''
    registered_modules = []
    for am in settings.modules:
        mod = __import__(am[0])
        moduleinst = getattr(mod, am[1])()
        moduleinst.settings = settings
        registered_modules.append(moduleinst)
    return registered_modules
#
# Append code generation
#        
appendtemplate = '''//=============================================================================//
// This file is automatically generated. CHANGES WILL BE LOST.
//=============================================================================//
#include "cbase.h"
#include "srcpy.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

using namespace boost::python;

// The init method is in one of the generated files declared
#ifdef _WIN32
%(win32decls)s
#else
%(unixdecls)s
#endif // _WIN32

// The append function
void Append%(AppendFunctionName)sModules()
{
%(appendlist)s
}
'''

def GenerateAppendCode(f, modulenames, dllname):
    win32decls = []
    unixdecls = []
    appendlist = []
    for name in modulenames:
        win32decls.append('extern "C" __declspec(dllexport) PyObject* PyInit_%s();' % (name))
        unixdecls.append('extern "C"  PyObject* PyInit_%s();' % (name))
        appendlist.append('\tAPPEND_MODULE(%s)' % (name))
        
        
    f.write(appendtemplate % {
        'win32decls' : '\n'.join(win32decls),
        'unixdecls' : '\n'.join(unixdecls),
        'appendlist' : '\n'.join(appendlist),
        'AppendFunctionName' : dllname[0].capitalize() + dllname[1:len(dllname)],
    })

def GenerateAppendFile(path, module_names, dll_name):
    ''' Writes the append file, which registers all modules in Python.'''
    filename = 'src_append_%s.cpp' % (dll_name)
    path = os.path.join(path, filename)
    with open(path, 'w+') as fp:
        GenerateAppendCode(fp, module_names, dll_name)
    return path

def GetIncludePath(path):
    # TODO: do this properly
    if path.startswith('..\game\shared'):
        return path.replace('..\game', '..') 
    elif path.startswith('..\game\server\\'):
        return path.replace('..\game\server\\', '') 
    elif path.startswith('..\game\client\\'):
        return path.replace('..\game\client\\', '')
    return path
        
def GetFilenames(rm, isclient=False):
    rm.isclient = isclient
    rm.isserver = not isclient
    
    path = GetIncludePath(rm.path)
    
    if not rm.split:
        return [os.path.join(path, '%s.cpp' % (rm.module_name))]
    else:
        files = os.listdir(os.path.join(rm.path, rm.module_name))
        files = filter(lambda f: f.endswith('.cpp'), files)
        return map(lambda f: os.path.join(path, rm.module_name, f), files)

def ParseModules(settings, specificmodule=None, appendfileonly=False):
    ''' Main parse function.
    
        Args:
            settings (module): Module containing settings for this configuration.
            specificmodule (str): Parse a single specific module.
            appendfileonly (bool): Only generate the append file.
    '''
    # Keep a list of the append names
    client_modules = []
    server_modules = []
    shared_modules = []
    
    # Keep a list of the filenames
    client_filenames = []
    server_filenames = []
    shared_filenames = []
    
    # Add search paths and create list of modules to be parsed/exposed
    for path in settings.searchpaths:
        sys.path.append(path)
    
    moduleinstances = RegisterModules(settings)
    
    for rm in moduleinstances:
        assert rm.module_name, 'Modules must have a valid name'
        
        # Check if we should parse this module
        if not appendfileonly and (not specificmodule or specificmodule == rm.module_name):
            # Generate binding code
            print('Generating %s...' % (rm.module_name))
            rs = rm.Run()
    
        # Build module list for append code
        if rm.module_type == 'client':
            client_modules.append(rm.module_name)
            client_filenames.extend(GetFilenames(rm))
        elif rm.module_type == 'server':
            server_modules.append(rm.module_name)
            server_filenames.extend(GetFilenames(rm))
        else:
            shared_modules.append(rm.module_name)
            if rm.split:
                client_filenames.extend(GetFilenames(rm, isclient=True))
                server_filenames.extend(GetFilenames(rm, isclient=False))
            else:
                shared_filenames.extend(GetFilenames(rm))

    # Generate new append files if needed (add modules to Python on initialization)
    clientappendfile = GenerateAppendFile(settings.client_path, client_modules, 'client')
    serverappendfile = GenerateAppendFile(settings.server_path, server_modules, 'server')
    sharedappendfile = GenerateAppendFile(settings.shared_path, shared_modules, 'shared')
    
    # Add python files for autoupdatevxproj setting if specified
    if settings.addpythonfiles:
        client_filenames.extend(map(os.path.normpath, settings.pythonfiles_client))
        server_filenames.extend(map(os.path.normpath, settings.pythonfiles_server))
        shared_filenames.extend(map(os.path.normpath, settings.pythonfiles_shared))
    
    # Add append files for autoupdatevxproj setting if specified
    if client_filenames: 
        client_filenames.append(GetIncludePath(clientappendfile))
    if server_filenames: 
        server_filenames.append(GetIncludePath(serverappendfile))
    if shared_filenames: 
        shared_filenames.append(GetIncludePath(sharedappendfile))
    
    # Update project files if specified by adding or removing missing/deleted files
    # TODO: Update this for VPC
    '''if settings.autoupdatevxproj:
        # Server Project
        allserverfilenames = shared_filenames+server_filenames
        vcxprojupdate.UpdateChanged(allserverfilenames, settings.vcxprojserver)
        
        # Client Project
        allclientfilenames = shared_filenames+client_filenames
        vcxprojupdate.UpdateChanged(allclientfilenames, settings.vcxprojclient)'''
        