// This file has been generated by Py++.

#include "cbase.h"
#ifdef CLIENT_DLL
#include "__array_1.pypp.hpp"

#include "cbase.h"

#include "gamerules.h"

#include "multiplay_gamerules.h"

#include "teamplay_gamerules.h"

#include "c_recipientfilter.h"

#include "tier0/icommandline.h"

#include "convar.h"

#include "igameevents.h"

#include "irecipientfilter.h"

#include "srcpy_gameinterface.h"

#include "cdll_int.h"

#include "srcpy_gameinterface_converters.h"

#include "srcpy.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct CBaseGameSystem_wrapper : CBaseGameSystem, bp::wrapper< CBaseGameSystem > {

    CBaseGameSystem_wrapper(CBaseGameSystem const & arg )
    : CBaseGameSystem( arg )
      , bp::wrapper< CBaseGameSystem >(){
        // copy constructor
        
    }

    CBaseGameSystem_wrapper()
    : CBaseGameSystem()
      , bp::wrapper< CBaseGameSystem >(){
        // null constructor
        
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Init(  );
            }
        else
            return this->CBaseGameSystem::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystem::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystem::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystem::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystem::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystem::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystem::LevelShutdownPreEntity( );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Name(  );
            }
        else
            return this->CBaseGameSystem::Name(  );
    }
    
    char const * default_Name(  ) {
        return CBaseGameSystem::Name( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnRestore(  );
            }
        else
            this->CBaseGameSystem::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystem::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnSave(  );
            }
        else
            this->CBaseGameSystem::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystem::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::PostInit(  );
            }
        else
            this->CBaseGameSystem::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystem::PostInit( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::Shutdown(  );
            }
        else
            this->CBaseGameSystem::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystem::Shutdown( );
    }

};

struct CAutoGameSystem_wrapper : CAutoGameSystem, bp::wrapper< CAutoGameSystem > {

    CAutoGameSystem_wrapper(CAutoGameSystem const & arg )
    : CAutoGameSystem( arg )
      , bp::wrapper< CAutoGameSystem >(){
        // copy constructor
        
    }

    CAutoGameSystem_wrapper(char const * name=0 )
    : CAutoGameSystem( name )
      , bp::wrapper< CAutoGameSystem >(){
        // constructor
    
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CAutoGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAutoGameSystem::Name(  );
            }
        else
            return this->CAutoGameSystem::Name(  );
    }
    
    char const * default_Name(  ) {
        return CAutoGameSystem::Name( );
    }

    static ::CAutoGameSystem * get_m_pNext(CAutoGameSystem const & inst ){
        return inst.m_pNext;
    }
    
    static void set_m_pNext( CAutoGameSystem & inst, ::CAutoGameSystem * new_value ){ 
        inst.m_pNext = new_value;
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Init(  );
            }
        else
            return this->CBaseGameSystem::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystem::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystem::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystem::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystem::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystem::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystem::LevelShutdownPreEntity( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnRestore(  );
            }
        else
            this->CBaseGameSystem::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystem::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnSave(  );
            }
        else
            this->CBaseGameSystem::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystem::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::PostInit(  );
            }
        else
            this->CBaseGameSystem::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystem::PostInit( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::Shutdown(  );
            }
        else
            this->CBaseGameSystem::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystem::Shutdown( );
    }

};

struct CBaseGameSystemPerFrame_wrapper : CBaseGameSystemPerFrame, bp::wrapper< CBaseGameSystemPerFrame > {

    CBaseGameSystemPerFrame_wrapper(CBaseGameSystemPerFrame const & arg )
    : CBaseGameSystemPerFrame( arg )
      , bp::wrapper< CBaseGameSystemPerFrame >(){
        // copy constructor
        
    }

    CBaseGameSystemPerFrame_wrapper()
    : CBaseGameSystemPerFrame()
      , bp::wrapper< CBaseGameSystemPerFrame >(){
        // null constructor
        
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Init(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystemPerFrame::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreEntity( );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Name(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Name(  );
    }
    
    char const * default_Name(  ) {
        return CBaseGameSystemPerFrame::Name( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnRestore(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystemPerFrame::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnSave(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystemPerFrame::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostInit(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystemPerFrame::PostInit( );
    }

    virtual void PostRender(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostRender: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostRender(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostRender = this->get_override( "PostRender" );
        if( func_PostRender.ptr() != Py_None )
            try {
                func_PostRender(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostRender(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostRender(  );
    }
    
    void default_PostRender(  ) {
        CBaseGameSystemPerFrame::PostRender( );
    }

    virtual void PreRender(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PreRender: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PreRender(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PreRender = this->get_override( "PreRender" );
        if( func_PreRender.ptr() != Py_None )
            try {
                func_PreRender(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PreRender(  );
            }
        else
            this->CBaseGameSystemPerFrame::PreRender(  );
    }
    
    void default_PreRender(  ) {
        CBaseGameSystemPerFrame::PreRender( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Shutdown(  );
            }
        else
            this->CBaseGameSystemPerFrame::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystemPerFrame::Shutdown( );
    }

    virtual void Update( float frametime ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Update: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Update( frametime ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Update = this->get_override( "Update" );
        if( func_Update.ptr() != Py_None )
            try {
                func_Update( frametime );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Update( frametime );
            }
        else
            this->CBaseGameSystemPerFrame::Update( frametime );
    }
    
    void default_Update( float frametime ) {
        CBaseGameSystemPerFrame::Update( frametime );
    }

};

struct CAutoGameSystemPerFrame_wrapper : CAutoGameSystemPerFrame, bp::wrapper< CAutoGameSystemPerFrame > {

    CAutoGameSystemPerFrame_wrapper(CAutoGameSystemPerFrame const & arg )
    : CAutoGameSystemPerFrame( arg )
      , bp::wrapper< CAutoGameSystemPerFrame >(){
        // copy constructor
        
    }

    CAutoGameSystemPerFrame_wrapper(char const * name=0 )
    : CAutoGameSystemPerFrame( name )
      , bp::wrapper< CAutoGameSystemPerFrame >(){
        // constructor
    
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CAutoGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAutoGameSystemPerFrame::Name(  );
            }
        else
            return this->CAutoGameSystemPerFrame::Name(  );
    }
    
    char const * default_Name(  ) {
        return CAutoGameSystemPerFrame::Name( );
    }

    static ::CAutoGameSystemPerFrame * get_m_pNext(CAutoGameSystemPerFrame const & inst ){
        return inst.m_pNext;
    }
    
    static void set_m_pNext( CAutoGameSystemPerFrame & inst, ::CAutoGameSystemPerFrame * new_value ){ 
        inst.m_pNext = new_value;
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Init(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystemPerFrame::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreEntity( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnRestore(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystemPerFrame::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnSave(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystemPerFrame::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostInit(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystemPerFrame::PostInit( );
    }

    virtual void PostRender(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostRender: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostRender(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostRender = this->get_override( "PostRender" );
        if( func_PostRender.ptr() != Py_None )
            try {
                func_PostRender(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostRender(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostRender(  );
    }
    
    void default_PostRender(  ) {
        CBaseGameSystemPerFrame::PostRender( );
    }

    virtual void PreRender(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PreRender: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PreRender(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PreRender = this->get_override( "PreRender" );
        if( func_PreRender.ptr() != Py_None )
            try {
                func_PreRender(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PreRender(  );
            }
        else
            this->CBaseGameSystemPerFrame::PreRender(  );
    }
    
    void default_PreRender(  ) {
        CBaseGameSystemPerFrame::PreRender( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Shutdown(  );
            }
        else
            this->CBaseGameSystemPerFrame::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystemPerFrame::Shutdown( );
    }

    virtual void Update( float frametime ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Update: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Update( frametime ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Update = this->get_override( "Update" );
        if( func_Update.ptr() != Py_None )
            try {
                func_Update( frametime );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Update( frametime );
            }
        else
            this->CBaseGameSystemPerFrame::Update( frametime );
    }
    
    void default_Update( float frametime ) {
        CBaseGameSystemPerFrame::Update( frametime );
    }

};

struct ICommandLine_wrapper : ICommandLine, bp::wrapper< ICommandLine > {

    ICommandLine_wrapper()
    : ICommandLine()
      , bp::wrapper< ICommandLine >(){
        // null constructor
        
    }

    virtual void AppendParm( char const * pszParm, char const * pszValues ){
        bp::override func_AppendParm = this->get_override( "AppendParm" );
        try {
            func_AppendParm( pszParm, pszValues );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * CheckParm( char const * psz, char const * * ppszValue=0 ) const {
        bp::override func_CheckParm = this->get_override( "CheckParm" );
        try {
            return func_CheckParm( psz, ppszValue );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void CreateCmdLine( char const * commandline ){
        bp::override func_CreateCmdLine = this->get_override( "CreateCmdLine" );
        try {
            func_CreateCmdLine( commandline );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void CreateCmdLine( int argc, char * * argv ){
        bp::override func_CreateCmdLine = this->get_override( "CreateCmdLine" );
        try {
            func_CreateCmdLine( argc, argv );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int FindParm( char const * psz ) const {
        bp::override func_FindParm = this->get_override( "FindParm" );
        try {
            return func_FindParm( psz );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * GetCmdLine(  ) const {
        bp::override func_GetCmdLine = this->get_override( "GetCmdLine" );
        try {
            return func_GetCmdLine(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * GetParm( int nIndex ) const {
        bp::override func_GetParm = this->get_override( "GetParm" );
        try {
            return func_GetParm( nIndex );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int ParmCount(  ) const {
        bp::override func_ParmCount = this->get_override( "ParmCount" );
        try {
            return func_ParmCount(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * ParmValue( char const * psz, char const * pDefaultVal=0 ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, pDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int ParmValue( char const * psz, int nDefaultVal ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, nDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float ParmValue( char const * psz, float flDefaultVal ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, flDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void RemoveParm( char const * parm ){
        bp::override func_RemoveParm = this->get_override( "RemoveParm" );
        try {
            func_RemoveParm( parm );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void SetParm( int nIndex, char const * pNewParm ){
        bp::override func_SetParm = this->get_override( "SetParm" );
        try {
            func_SetParm( nIndex, pNewParm );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

};

struct PyGameEventListener_wrapper : PyGameEventListener, bp::wrapper< PyGameEventListener > {

    PyGameEventListener_wrapper(PyGameEventListener const & arg )
    : PyGameEventListener( arg )
      , bp::wrapper< PyGameEventListener >(){
        // copy constructor
        
    }

    PyGameEventListener_wrapper()
    : PyGameEventListener()
      , bp::wrapper< PyGameEventListener >(){
        // null constructor
        
    }

    virtual void PyFireGameEvent( ::boost::python::object event ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FireGameEvent: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyFireGameEvent( event ) of Class: PyGameEventListener\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FireGameEvent = this->get_override( "FireGameEvent" );
        if( func_FireGameEvent.ptr() != Py_None )
            try {
                func_FireGameEvent( event );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->PyGameEventListener::PyFireGameEvent( event );
            }
        else
            this->PyGameEventListener::PyFireGameEvent( event );
    }
    
    void default_FireGameEvent( ::boost::python::object event ) {
        PyGameEventListener::PyFireGameEvent( event );
    }

};

struct PyVEngineClient_wrapper : PyVEngineClient, bp::wrapper< PyVEngineClient > {

    PyVEngineClient_wrapper(PyVEngineClient const & arg )
    : PyVEngineClient( arg )
      , bp::wrapper< PyVEngineClient >(){
        // copy constructor
        
    }

    PyVEngineClient_wrapper()
    : PyVEngineClient()
      , bp::wrapper< PyVEngineClient >(){
        // null constructor
        
    }

    virtual ::Vector GetLightForPoint( ::Vector const & pos, bool clamp ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "GetLightForPoint: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling GetLightForPoint( boost::ref(pos), clamp ) of Class: PyVEngineClient\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_GetLightForPoint = this->get_override( "GetLightForPoint" );
        if( func_GetLightForPoint.ptr() != Py_None )
            try {
                return func_GetLightForPoint( boost::ref(pos), clamp );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->PyVEngineClient::GetLightForPoint( boost::ref(pos), clamp );
            }
        else
            return this->PyVEngineClient::GetLightForPoint( boost::ref(pos), clamp );
    }
    
    ::Vector default_GetLightForPoint( ::Vector const & pos, bool clamp ) {
        return PyVEngineClient::GetLightForPoint( boost::ref(pos), clamp );
    }

};

struct dheader_t_wrapper : dheader_t, bp::wrapper< dheader_t > {

    dheader_t_wrapper(dheader_t const & arg )
    : dheader_t( arg )
      , bp::wrapper< dheader_t >(){
        // copy constructor
        
    }

    dheader_t_wrapper()
    : dheader_t()
      , bp::wrapper< dheader_t >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64>
    pyplusplus_lumps_wrapper( ::dheader_t & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64>( inst.lumps );
    }

};

struct lump_t_wrapper : lump_t, bp::wrapper< lump_t > {

    lump_t_wrapper(lump_t const & arg )
    : lump_t( arg )
      , bp::wrapper< lump_t >(){
        // copy constructor
        
    }

    lump_t_wrapper()
    : lump_t()
      , bp::wrapper< lump_t >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 4>
    pyplusplus_fourCC_wrapper( ::lump_t & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 4>( inst.fourCC );
    }

};

struct py_player_info_s_wrapper : py_player_info_s, bp::wrapper< py_player_info_s > {

    py_player_info_s_wrapper(py_player_info_s const & arg )
    : py_player_info_s( arg )
      , bp::wrapper< py_player_info_s >(){
        // copy constructor
        
    }

    py_player_info_s_wrapper()
    : py_player_info_s()
      , bp::wrapper< py_player_info_s >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< unsigned int, 4>
    pyplusplus_customFiles_wrapper( ::py_player_info_s & inst ){
        return pyplusplus::containers::static_sized::array_1_t< unsigned int, 4>( inst.customFiles );
    }

};

BOOST_PYTHON_MODULE(_gameinterface){
    bp::docstring_options doc_options( true, true, false );

    bp::enum_< FilesystemMountRetval_t>("FilesystemMountRetval_t")
        .value("FILESYSTEM_MOUNT_OK", FILESYSTEM_MOUNT_OK)
        .value("FILESYSTEM_MOUNT_FAILED", FILESYSTEM_MOUNT_FAILED)
        .export_values()
        ;

    bp::enum_< SearchPathAdd_t>("SearchPathAdd_t")
        .value("PATH_ADD_TO_HEAD", PATH_ADD_TO_HEAD)
        .value("PATH_ADD_TO_TAIL", PATH_ADD_TO_TAIL)
        .export_values()
        ;

    bp::class_< IGameSystem, boost::noncopyable >( "IGameSystem", bp::no_init )    
        .def( 
            "Add"
            , (void (*)( ::IGameSystem * ))( &::IGameSystem::Add )
            , ( bp::arg("pSys") ) )    
        .def( 
            "Init"
            , (bool ( ::IGameSystem::* )(  ) )( &::IGameSystem::Init ) )    
        .def( 
            "InitAllSystems"
            , (bool (*)(  ))( &::IGameSystem::InitAllSystems ) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::IGameSystem::* )(  ) )( &::IGameSystem::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelInitPostEntity ) )    
        .def( 
            "LevelInitPostEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelInitPostEntityAllSystems ) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelInitPreEntity ) )    
        .def( 
            "LevelInitPreEntityAllSystems"
            , (void (*)( char const * ))( &::IGameSystem::LevelInitPreEntityAllSystems )
            , ( bp::arg("pMapName") ) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPostEntity ) )    
        .def( 
            "LevelShutdownPostEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPostEntityAllSystems ) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPreClearSteamAPIContext ) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContextAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPreClearSteamAPIContextAllSystems ) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPreEntity ) )    
        .def( 
            "LevelShutdownPreEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPreEntityAllSystems ) )    
        .def( 
            "MapName"
            , (char const * (*)(  ))( &::IGameSystem::MapName ) )    
        .def( 
            "Name"
            , (char const * ( ::IGameSystem::* )(  ) )( &::IGameSystem::Name ) )    
        .def( 
            "OnRestore"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::OnRestore ) )    
        .def( 
            "OnRestoreAllSystems"
            , (void (*)(  ))( &::IGameSystem::OnRestoreAllSystems ) )    
        .def( 
            "OnSave"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::OnSave ) )    
        .def( 
            "OnSaveAllSystems"
            , (void (*)(  ))( &::IGameSystem::OnSaveAllSystems ) )    
        .def( 
            "PostInit"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::PostInit ) )    
        .def( 
            "PostInitAllSystems"
            , (void (*)(  ))( &::IGameSystem::PostInitAllSystems ) )    
        .def( 
            "PostRenderAllSystems"
            , (void (*)(  ))( &::IGameSystem::PostRenderAllSystems ) )    
        .def( 
            "PreRenderAllSystems"
            , (void (*)(  ))( &::IGameSystem::PreRenderAllSystems ) )    
        .def( 
            "Remove"
            , (void (*)( ::IGameSystem * ))( &::IGameSystem::Remove )
            , ( bp::arg("pSys") ) )    
        .def( 
            "RemoveAll"
            , (void (*)(  ))( &::IGameSystem::RemoveAll ) )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::SafeRemoveIfDesired ) )    
        .def( 
            "SafeRemoveIfDesiredAllSystems"
            , (void (*)(  ))( &::IGameSystem::SafeRemoveIfDesiredAllSystems ) )    
        .def( 
            "Shutdown"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::Shutdown ) )    
        .def( 
            "ShutdownAllSystems"
            , (void (*)(  ))( &::IGameSystem::ShutdownAllSystems ) )    
        .def( 
            "UpdateAllSystems"
            , (void (*)( float ))( &::IGameSystem::UpdateAllSystems )
            , ( bp::arg("frametime") ) )    
        .staticmethod( "Add" )    
        .staticmethod( "InitAllSystems" )    
        .staticmethod( "LevelInitPostEntityAllSystems" )    
        .staticmethod( "LevelInitPreEntityAllSystems" )    
        .staticmethod( "LevelShutdownPostEntityAllSystems" )    
        .staticmethod( "LevelShutdownPreClearSteamAPIContextAllSystems" )    
        .staticmethod( "LevelShutdownPreEntityAllSystems" )    
        .staticmethod( "MapName" )    
        .staticmethod( "OnRestoreAllSystems" )    
        .staticmethod( "OnSaveAllSystems" )    
        .staticmethod( "PostInitAllSystems" )    
        .staticmethod( "PostRenderAllSystems" )    
        .staticmethod( "PreRenderAllSystems" )    
        .staticmethod( "Remove" )    
        .staticmethod( "RemoveAll" )    
        .staticmethod( "SafeRemoveIfDesiredAllSystems" )    
        .staticmethod( "ShutdownAllSystems" )    
        .staticmethod( "UpdateAllSystems" );

    bp::class_< CBaseGameSystem_wrapper, bp::bases< IGameSystem > >( "CBaseGameSystem" )    
        .def( 
            "Init"
            , (bool ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Init)
            , (bool ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Init) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::CBaseGameSystem::* )(  ) )( &::CBaseGameSystem::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelInitPostEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelInitPostEntity) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelInitPreEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelInitPreEntity) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPostEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPostEntity) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPreClearSteamAPIContext) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPreEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPreEntity) )    
        .def( 
            "Name"
            , (char const * ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Name)
            , (char const * ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Name) )    
        .def( 
            "OnRestore"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::OnRestore)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_OnRestore) )    
        .def( 
            "OnSave"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::OnSave)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_OnSave) )    
        .def( 
            "PostInit"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::PostInit)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_PostInit) )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::CBaseGameSystem::* )(  ) )( &::CBaseGameSystem::SafeRemoveIfDesired ) )    
        .def( 
            "Shutdown"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Shutdown)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Shutdown) );

    { //::CAutoGameSystem
        typedef bp::class_< CAutoGameSystem_wrapper, bp::bases< CBaseGameSystem > > AutoGameSystem_exposer_t;
        AutoGameSystem_exposer_t AutoGameSystem_exposer = AutoGameSystem_exposer_t( "AutoGameSystem", bp::init< bp::optional< char const * > >(( bp::arg("name")=bp::object() )) );
        bp::scope AutoGameSystem_scope( AutoGameSystem_exposer );
        bp::implicitly_convertible< char const *, CAutoGameSystem >();
        { //::CAutoGameSystem::Name
        
            typedef char const * ( ::CAutoGameSystem::*Name_function_type )(  ) ;
            typedef char const * ( CAutoGameSystem_wrapper::*default_Name_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Name"
                , Name_function_type(&::CAutoGameSystem::Name)
                , default_Name_function_type(&CAutoGameSystem_wrapper::default_Name) );
        
        }
        AutoGameSystem_exposer.add_property( "m_pNext"
                    , bp::make_function( (::CAutoGameSystem * (*)( ::CAutoGameSystem const & ))(&CAutoGameSystem_wrapper::get_m_pNext), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::CAutoGameSystem &,::CAutoGameSystem * ))(&CAutoGameSystem_wrapper::set_m_pNext), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        { //::CBaseGameSystem::Init
        
            typedef bool ( ::CBaseGameSystem::*Init_function_type )(  ) ;
            typedef bool ( CAutoGameSystem_wrapper::*default_Init_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Init"
                , Init_function_type(&::CBaseGameSystem::Init)
                , default_Init_function_type(&CAutoGameSystem_wrapper::default_Init) );
        
        }
        { //::CBaseGameSystem::LevelInitPostEntity
        
            typedef void ( ::CBaseGameSystem::*LevelInitPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelInitPostEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelInitPostEntity"
                , LevelInitPostEntity_function_type(&::CBaseGameSystem::LevelInitPostEntity)
                , default_LevelInitPostEntity_function_type(&CAutoGameSystem_wrapper::default_LevelInitPostEntity) );
        
        }
        { //::CBaseGameSystem::LevelInitPreEntity
        
            typedef void ( ::CBaseGameSystem::*LevelInitPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelInitPreEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelInitPreEntity"
                , LevelInitPreEntity_function_type(&::CBaseGameSystem::LevelInitPreEntity)
                , default_LevelInitPreEntity_function_type(&CAutoGameSystem_wrapper::default_LevelInitPreEntity) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPostEntity
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPostEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPostEntity"
                , LevelShutdownPostEntity_function_type(&::CBaseGameSystem::LevelShutdownPostEntity)
                , default_LevelShutdownPostEntity_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPostEntity) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPreClearSteamAPIContext"
                , LevelShutdownPreClearSteamAPIContext_function_type(&::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext)
                , default_LevelShutdownPreClearSteamAPIContext_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPreClearSteamAPIContext) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPreEntity
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPreEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPreEntity"
                , LevelShutdownPreEntity_function_type(&::CBaseGameSystem::LevelShutdownPreEntity)
                , default_LevelShutdownPreEntity_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPreEntity) );
        
        }
        { //::CBaseGameSystem::OnRestore
        
            typedef void ( ::CBaseGameSystem::*OnRestore_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_OnRestore_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "OnRestore"
                , OnRestore_function_type(&::CBaseGameSystem::OnRestore)
                , default_OnRestore_function_type(&CAutoGameSystem_wrapper::default_OnRestore) );
        
        }
        { //::CBaseGameSystem::OnSave
        
            typedef void ( ::CBaseGameSystem::*OnSave_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_OnSave_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "OnSave"
                , OnSave_function_type(&::CBaseGameSystem::OnSave)
                , default_OnSave_function_type(&CAutoGameSystem_wrapper::default_OnSave) );
        
        }
        { //::CBaseGameSystem::PostInit
        
            typedef void ( ::CBaseGameSystem::*PostInit_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_PostInit_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "PostInit"
                , PostInit_function_type(&::CBaseGameSystem::PostInit)
                , default_PostInit_function_type(&CAutoGameSystem_wrapper::default_PostInit) );
        
        }
        { //::CBaseGameSystem::Shutdown
        
            typedef void ( ::CBaseGameSystem::*Shutdown_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_Shutdown_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Shutdown"
                , Shutdown_function_type(&::CBaseGameSystem::Shutdown)
                , default_Shutdown_function_type(&CAutoGameSystem_wrapper::default_Shutdown) );
        
        }
    }

    bp::class_< CBaseGameSystemPerFrame_wrapper >( "CBaseGameSystemPerFrame" )    
        .def( 
            "Init"
            , (bool ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Init)
            , (bool ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Init) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::CBaseGameSystemPerFrame::* )(  ) )( &::CBaseGameSystemPerFrame::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelInitPostEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelInitPostEntity) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelInitPreEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelInitPreEntity) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPostEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPostEntity) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPreClearSteamAPIContext) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPreEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPreEntity) )    
        .def( 
            "Name"
            , (char const * ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Name)
            , (char const * ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Name) )    
        .def( 
            "OnRestore"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::OnRestore)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_OnRestore) )    
        .def( 
            "OnSave"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::OnSave)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_OnSave) )    
        .def( 
            "PostInit"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::PostInit)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_PostInit) )    
        .def( 
            "PostRender"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::PostRender)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_PostRender) )    
        .def( 
            "PreRender"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::PreRender)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_PreRender) )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )( &::CBaseGameSystemPerFrame::SafeRemoveIfDesired ) )    
        .def( 
            "Shutdown"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Shutdown)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Shutdown) )    
        .def( 
            "Update"
            , (void ( ::CBaseGameSystemPerFrame::* )( float ) )(&::CBaseGameSystemPerFrame::Update)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )( float ) )(&CBaseGameSystemPerFrame_wrapper::default_Update)
            , ( bp::arg("frametime") ) );

    { //::CAutoGameSystemPerFrame
        typedef bp::class_< CAutoGameSystemPerFrame_wrapper, bp::bases< CBaseGameSystemPerFrame > > AutoGameSystemPerFrame_exposer_t;
        AutoGameSystemPerFrame_exposer_t AutoGameSystemPerFrame_exposer = AutoGameSystemPerFrame_exposer_t( "AutoGameSystemPerFrame", bp::init< bp::optional< char const * > >(( bp::arg("name")=bp::object() )) );
        bp::scope AutoGameSystemPerFrame_scope( AutoGameSystemPerFrame_exposer );
        bp::implicitly_convertible< char const *, CAutoGameSystemPerFrame >();
        { //::CAutoGameSystemPerFrame::Name
        
            typedef char const * ( ::CAutoGameSystemPerFrame::*Name_function_type )(  ) ;
            typedef char const * ( CAutoGameSystemPerFrame_wrapper::*default_Name_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Name"
                , Name_function_type(&::CAutoGameSystemPerFrame::Name)
                , default_Name_function_type(&CAutoGameSystemPerFrame_wrapper::default_Name) );
        
        }
        AutoGameSystemPerFrame_exposer.add_property( "m_pNext"
                    , bp::make_function( (::CAutoGameSystemPerFrame * (*)( ::CAutoGameSystemPerFrame const & ))(&CAutoGameSystemPerFrame_wrapper::get_m_pNext), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::CAutoGameSystemPerFrame &,::CAutoGameSystemPerFrame * ))(&CAutoGameSystemPerFrame_wrapper::set_m_pNext), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        { //::CBaseGameSystemPerFrame::Init
        
            typedef bool ( ::CBaseGameSystemPerFrame::*Init_function_type )(  ) ;
            typedef bool ( CAutoGameSystemPerFrame_wrapper::*default_Init_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Init"
                , Init_function_type(&::CBaseGameSystemPerFrame::Init)
                , default_Init_function_type(&CAutoGameSystemPerFrame_wrapper::default_Init) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelInitPostEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelInitPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelInitPostEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelInitPostEntity"
                , LevelInitPostEntity_function_type(&::CBaseGameSystemPerFrame::LevelInitPostEntity)
                , default_LevelInitPostEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelInitPostEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelInitPreEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelInitPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelInitPreEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelInitPreEntity"
                , LevelInitPreEntity_function_type(&::CBaseGameSystemPerFrame::LevelInitPreEntity)
                , default_LevelInitPreEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelInitPreEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPostEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPostEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPostEntity"
                , LevelShutdownPostEntity_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPostEntity)
                , default_LevelShutdownPostEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPostEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPreClearSteamAPIContext"
                , LevelShutdownPreClearSteamAPIContext_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext)
                , default_LevelShutdownPreClearSteamAPIContext_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPreClearSteamAPIContext) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPreEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPreEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPreEntity"
                , LevelShutdownPreEntity_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPreEntity)
                , default_LevelShutdownPreEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPreEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::OnRestore
        
            typedef void ( ::CBaseGameSystemPerFrame::*OnRestore_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_OnRestore_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "OnRestore"
                , OnRestore_function_type(&::CBaseGameSystemPerFrame::OnRestore)
                , default_OnRestore_function_type(&CAutoGameSystemPerFrame_wrapper::default_OnRestore) );
        
        }
        { //::CBaseGameSystemPerFrame::OnSave
        
            typedef void ( ::CBaseGameSystemPerFrame::*OnSave_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_OnSave_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "OnSave"
                , OnSave_function_type(&::CBaseGameSystemPerFrame::OnSave)
                , default_OnSave_function_type(&CAutoGameSystemPerFrame_wrapper::default_OnSave) );
        
        }
        { //::CBaseGameSystemPerFrame::PostInit
        
            typedef void ( ::CBaseGameSystemPerFrame::*PostInit_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_PostInit_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "PostInit"
                , PostInit_function_type(&::CBaseGameSystemPerFrame::PostInit)
                , default_PostInit_function_type(&CAutoGameSystemPerFrame_wrapper::default_PostInit) );
        
        }
        { //::CBaseGameSystemPerFrame::PostRender
        
            typedef void ( ::CBaseGameSystemPerFrame::*PostRender_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_PostRender_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "PostRender"
                , PostRender_function_type(&::CBaseGameSystemPerFrame::PostRender)
                , default_PostRender_function_type(&CAutoGameSystemPerFrame_wrapper::default_PostRender) );
        
        }
        { //::CBaseGameSystemPerFrame::PreRender
        
            typedef void ( ::CBaseGameSystemPerFrame::*PreRender_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_PreRender_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "PreRender"
                , PreRender_function_type(&::CBaseGameSystemPerFrame::PreRender)
                , default_PreRender_function_type(&CAutoGameSystemPerFrame_wrapper::default_PreRender) );
        
        }
        { //::CBaseGameSystemPerFrame::Shutdown
        
            typedef void ( ::CBaseGameSystemPerFrame::*Shutdown_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_Shutdown_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Shutdown"
                , Shutdown_function_type(&::CBaseGameSystemPerFrame::Shutdown)
                , default_Shutdown_function_type(&CAutoGameSystemPerFrame_wrapper::default_Shutdown) );
        
        }
        { //::CBaseGameSystemPerFrame::Update
        
            typedef void ( ::CBaseGameSystemPerFrame::*Update_function_type )( float ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_Update_function_type )( float ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Update"
                , Update_function_type(&::CBaseGameSystemPerFrame::Update)
                , default_Update_function_type(&CAutoGameSystemPerFrame_wrapper::default_Update)
                , ( bp::arg("frametime") ) );
        
        }
    }

    bp::class_< IRecipientFilter, boost::noncopyable >( "IRecipientFilter", bp::no_init )    
        .def( 
            "GetRecipientCount"
            , (int ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::GetRecipientCount ) )    
        .def( 
            "GetRecipientIndex"
            , (int ( ::IRecipientFilter::* )( int ) const)( &::IRecipientFilter::GetRecipientIndex )
            , ( bp::arg("slot") ) )    
        .def( 
            "IsInitMessage"
            , (bool ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::IsInitMessage ) )    
        .def( 
            "IsReliable"
            , (bool ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::IsReliable ) );

    bp::class_< C_RecipientFilter, bp::bases< IRecipientFilter >, boost::noncopyable >( "C_RecipientFilter", bp::no_init )    
        .def( bp::init< >() )    
        .def( 
            "AddAllPlayers"
            , (void ( ::C_RecipientFilter::* )(  ) )( &::C_RecipientFilter::AddAllPlayers ) )    
        .def( 
            "AddPlayersFromBitMask"
            , (void ( ::C_RecipientFilter::* )( ::CBitVec< 255 > & ) )( &::C_RecipientFilter::AddPlayersFromBitMask )
            , ( bp::arg("playerbits") ) )    
        .def( 
            "AddRecipient"
            , (void ( ::C_RecipientFilter::* )( ::C_BasePlayer * ) )( &::C_RecipientFilter::AddRecipient )
            , ( bp::arg("player") ) )    
        .def( 
            "AddRecipientsByPAS"
            , (void ( ::C_RecipientFilter::* )( ::Vector const & ) )( &::C_RecipientFilter::AddRecipientsByPAS )
            , ( bp::arg("origin") ) )    
        .def( 
            "AddRecipientsByPVS"
            , (void ( ::C_RecipientFilter::* )( ::Vector const & ) )( &::C_RecipientFilter::AddRecipientsByPVS )
            , ( bp::arg("origin") ) )    
        .def( 
            "AddRecipientsByTeam"
            , (void ( ::C_RecipientFilter::* )( ::C_Team * ) )( &::C_RecipientFilter::AddRecipientsByTeam )
            , ( bp::arg("team") ) )    
        .def( 
            "CopyFrom"
            , (void ( ::C_RecipientFilter::* )( ::C_RecipientFilter const & ) )( &::C_RecipientFilter::CopyFrom )
            , ( bp::arg("src") ) )    
        .def( 
            "GetRecipientCount"
            , (int ( ::C_RecipientFilter::* )(  ) const)( &::C_RecipientFilter::GetRecipientCount ) )    
        .def( 
            "GetRecipientIndex"
            , (int ( ::C_RecipientFilter::* )( int ) const)( &::C_RecipientFilter::GetRecipientIndex )
            , ( bp::arg("slot") ) )    
        .def( 
            "IgnorePredictionCull"
            , (bool ( ::C_RecipientFilter::* )(  ) const)( &::C_RecipientFilter::IgnorePredictionCull ) )    
        .def( 
            "IsInitMessage"
            , (bool ( ::C_RecipientFilter::* )(  ) const)( &::C_RecipientFilter::IsInitMessage ) )    
        .def( 
            "IsReliable"
            , (bool ( ::C_RecipientFilter::* )(  ) const)( &::C_RecipientFilter::IsReliable ) )    
        .def( 
            "IsUsingPredictionRules"
            , (bool ( ::C_RecipientFilter::* )(  ) const)( &::C_RecipientFilter::IsUsingPredictionRules ) )    
        .def( 
            "MakeReliable"
            , (void ( ::C_RecipientFilter::* )(  ) )( &::C_RecipientFilter::MakeReliable ) )    
        .def( 
            "RemoveRecipient"
            , (void ( ::C_RecipientFilter::* )( ::C_BasePlayer * ) )( &::C_RecipientFilter::RemoveRecipient )
            , ( bp::arg("player") ) )    
        .def( 
            "RemoveRecipientsByTeam"
            , (void ( ::C_RecipientFilter::* )( ::C_Team * ) )( &::C_RecipientFilter::RemoveRecipientsByTeam )
            , ( bp::arg("team") ) )    
        .def( 
            "Reset"
            , (void ( ::C_RecipientFilter::* )(  ) )( &::C_RecipientFilter::Reset ) )    
        .def( 
            "SetIgnorePredictionCull"
            , (void ( ::C_RecipientFilter::* )( bool ) )( &::C_RecipientFilter::SetIgnorePredictionCull )
            , ( bp::arg("ignore") ) )    
        .def( 
            "UsePredictionRules"
            , (void ( ::C_RecipientFilter::* )(  ) )( &::C_RecipientFilter::UsePredictionRules ) )    
        .def_readwrite( "m_Recipients", &C_RecipientFilter::m_Recipients )    
        .def_readwrite( "m_bIgnorePredictionCull", &C_RecipientFilter::m_bIgnorePredictionCull )    
        .def_readwrite( "m_bInitMessage", &C_RecipientFilter::m_bInitMessage )    
        .def_readwrite( "m_bReliable", &C_RecipientFilter::m_bReliable )    
        .def_readwrite( "m_bUsingPredictionRules", &C_RecipientFilter::m_bUsingPredictionRules );

    bp::class_< CBroadcastRecipientFilter, bp::bases< C_RecipientFilter >, boost::noncopyable >( "CBroadcastRecipientFilter", bp::init< >() );

    bp::class_< CCommand >( "CCommand", bp::init< >() )    
        .def( bp::init< int, char const * * >(( bp::arg("nArgC"), bp::arg("ppArgV") )) )    
        .def( 
            "Arg"
            , (char const * ( ::CCommand::* )( int ) const)( &::CCommand::Arg )
            , ( bp::arg("nIndex") ) )    
        .def( 
            "ArgC"
            , (int ( ::CCommand::* )(  ) const)( &::CCommand::ArgC ) )    
        .def( 
            "ArgS"
            , (char const * ( ::CCommand::* )(  ) const)( &::CCommand::ArgS ) )    
        .def( 
            "FindArg"
            , (char const * ( ::CCommand::* )( char const * ) const)( &::CCommand::FindArg )
            , ( bp::arg("pName") ) )    
        .def( 
            "FindArgInt"
            , (int ( ::CCommand::* )( char const *,int ) const)( &::CCommand::FindArgInt )
            , ( bp::arg("pName"), bp::arg("nDefaultVal") ) )    
        .def( 
            "GetCommandString"
            , (char const * ( ::CCommand::* )(  ) const)( &::CCommand::GetCommandString ) )    
        .def( 
            "MaxCommandLength"
            , (int (*)(  ))( &::CCommand::MaxCommandLength ) )    
        .def( 
            "Reset"
            , (void ( ::CCommand::* )(  ) )( &::CCommand::Reset ) )    
        .def( 
            "__getitem__"
            , (char const * ( ::CCommand::* )( int ) const)( &::CCommand::operator[] )
            , ( bp::arg("nIndex") ) )    
        .staticmethod( "MaxCommandLength" )    
        .def( 
            "__len__"
            , (int ( ::CCommand::* )(  ) const)( &::CCommand::ArgC ) );

    bp::class_< CLocalPlayerFilter, bp::bases< C_RecipientFilter >, boost::noncopyable >( "CLocalPlayerFilter", bp::init< >() );

    { //::CPASFilter
        typedef bp::class_< CPASFilter, bp::bases< C_RecipientFilter >, boost::noncopyable > CPASFilter_exposer_t;
        CPASFilter_exposer_t CPASFilter_exposer = CPASFilter_exposer_t( "CPASFilter", bp::init< Vector const & >(( bp::arg("origin") )) );
        bp::scope CPASFilter_scope( CPASFilter_exposer );
        bp::implicitly_convertible< Vector const &, CPASFilter >();
    }

    { //::CPASAttenuationFilter
        typedef bp::class_< CPASAttenuationFilter, bp::bases< CPASFilter >, boost::noncopyable > CPASAttenuationFilter_exposer_t;
        CPASAttenuationFilter_exposer_t CPASAttenuationFilter_exposer = CPASAttenuationFilter_exposer_t( "CPASAttenuationFilter", bp::init< C_BaseEntity *, bp::optional< float > >(( bp::arg("entity"), bp::arg("attenuation")=8.00000011920928955078125e-1f )) );
        bp::scope CPASAttenuationFilter_scope( CPASAttenuationFilter_exposer );
        bp::implicitly_convertible< C_BaseEntity *, CPASAttenuationFilter >();
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, bp::optional< float > >(( bp::arg("origin"), bp::arg("attenuation")=8.00000011920928955078125e-1f )) );
        bp::implicitly_convertible< Vector const &, CPASAttenuationFilter >();
        CPASAttenuationFilter_exposer.def( bp::init< C_BaseEntity *, char const * >(( bp::arg("entity"), bp::arg("lookupSound") )) );
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, char const * >(( bp::arg("origin"), bp::arg("lookupSound") )) );
        CPASAttenuationFilter_exposer.def( bp::init< C_BaseEntity *, char const *, HSOUNDSCRIPTHANDLE & >(( bp::arg("entity"), bp::arg("lookupSound"), bp::arg("handle") )) );
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, char const *, HSOUNDSCRIPTHANDLE & >(( bp::arg("origin"), bp::arg("lookupSound"), bp::arg("handle") )) );
    }

    { //::CPVSFilter
        typedef bp::class_< CPVSFilter, bp::bases< C_RecipientFilter >, boost::noncopyable > CPVSFilter_exposer_t;
        CPVSFilter_exposer_t CPVSFilter_exposer = CPVSFilter_exposer_t( "CPVSFilter", bp::init< Vector const & >(( bp::arg("origin") )) );
        bp::scope CPVSFilter_scope( CPVSFilter_exposer );
        bp::implicitly_convertible< Vector const &, CPVSFilter >();
    }

    bp::class_< CReliableBroadcastRecipientFilter, bp::bases< CBroadcastRecipientFilter >, boost::noncopyable >( "CReliableBroadcastRecipientFilter", bp::init< >() );

    { //::CSingleUserRecipientFilter
        typedef bp::class_< CSingleUserRecipientFilter, bp::bases< C_RecipientFilter >, boost::noncopyable > CSingleUserRecipientFilter_exposer_t;
        CSingleUserRecipientFilter_exposer_t CSingleUserRecipientFilter_exposer = CSingleUserRecipientFilter_exposer_t( "CSingleUserRecipientFilter", bp::init< C_BasePlayer * >(( bp::arg("player") )) );
        bp::scope CSingleUserRecipientFilter_scope( CSingleUserRecipientFilter_exposer );
        bp::implicitly_convertible< C_BasePlayer *, CSingleUserRecipientFilter >();
    }

    { //::ConVarRef
        typedef bp::class_< ConVarRef > ConVarRef_exposer_t;
        ConVarRef_exposer_t ConVarRef_exposer = ConVarRef_exposer_t( "ConVarRef", bp::init< char const * >(( bp::arg("pName") )) );
        bp::scope ConVarRef_scope( ConVarRef_exposer );
        bp::implicitly_convertible< char const *, ConVarRef >();
        ConVarRef_exposer.def( bp::init< char const *, bool >(( bp::arg("pName"), bp::arg("bIgnoreMissing") )) );
        ConVarRef_exposer.def( bp::init< IConVar * >(( bp::arg("pConVar") )) );
        bp::implicitly_convertible< IConVar *, ConVarRef >();
        { //::ConVarRef::GetBool
        
            typedef bool ( ::ConVarRef::*GetBool_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetBool"
                , GetBool_function_type( &::ConVarRef::GetBool ) );
        
        }
        { //::ConVarRef::GetDefault
        
            typedef char const * ( ::ConVarRef::*GetDefault_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetDefault"
                , GetDefault_function_type( &::ConVarRef::GetDefault ) );
        
        }
        { //::ConVarRef::GetFloat
        
            typedef float ( ::ConVarRef::*GetFloat_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetFloat"
                , GetFloat_function_type( &::ConVarRef::GetFloat ) );
        
        }
        { //::ConVarRef::GetInt
        
            typedef int ( ::ConVarRef::*GetInt_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetInt"
                , GetInt_function_type( &::ConVarRef::GetInt ) );
        
        }
        { //::ConVarRef::GetName
        
            typedef char const * ( ::ConVarRef::*GetName_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetName"
                , GetName_function_type( &::ConVarRef::GetName ) );
        
        }
        { //::ConVarRef::GetString
        
            typedef char const * ( ::ConVarRef::*GetString_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetString"
                , GetString_function_type( &::ConVarRef::GetString ) );
        
        }
        { //::ConVarRef::Init
        
            typedef void ( ::ConVarRef::*Init_function_type )( char const *,bool ) ;
            
            ConVarRef_exposer.def( 
                "Init"
                , Init_function_type( &::ConVarRef::Init )
                , ( bp::arg("pName"), bp::arg("bIgnoreMissing") ) );
        
        }
        { //::ConVarRef::IsFlagSet
        
            typedef bool ( ::ConVarRef::*IsFlagSet_function_type )( int ) const;
            
            ConVarRef_exposer.def( 
                "IsFlagSet"
                , IsFlagSet_function_type( &::ConVarRef::IsFlagSet )
                , ( bp::arg("nFlags") ) );
        
        }
        { //::ConVarRef::IsValid
        
            typedef bool ( ::ConVarRef::*IsValid_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "IsValid"
                , IsValid_function_type( &::ConVarRef::IsValid ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( char const * ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("pValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( float ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("flValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( int ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("nValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( bool ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("bValue") ) );
        
        }
    }

    bp::class_< ICommandLine_wrapper, boost::noncopyable >( "ICommandLine" )    
        .def( 
            "AppendParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const *,char const * ) )(&::ICommandLine::AppendParm) )
            , ( bp::arg("pszParm"), bp::arg("pszValues") ) )    
        .def( 
            "CheckParm"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( char const *,char const * * ) const)(&::ICommandLine::CheckParm) )
            , ( bp::arg("psz"), bp::arg("ppszValue")=bp::object() ) )    
        .def( 
            "CreateCmdLine"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const * ) )(&::ICommandLine::CreateCmdLine) )
            , ( bp::arg("commandline") ) )    
        .def( 
            "CreateCmdLine"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( int,char * * ) )(&::ICommandLine::CreateCmdLine) )
            , ( bp::arg("argc"), bp::arg("argv") ) )    
        .def( 
            "FindParm"
            , bp::pure_virtual( (int ( ::ICommandLine::* )( char const * ) const)(&::ICommandLine::FindParm) )
            , ( bp::arg("psz") ) )    
        .def( 
            "GetCmdLine"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )(  ) const)(&::ICommandLine::GetCmdLine) ) )    
        .def( 
            "GetParm"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( int ) const)(&::ICommandLine::GetParm) )
            , ( bp::arg("nIndex") ) )    
        .def( 
            "ParmCount"
            , bp::pure_virtual( (int ( ::ICommandLine::* )(  ) const)(&::ICommandLine::ParmCount) ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( char const *,char const * ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("pDefaultVal")=bp::object() ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (int ( ::ICommandLine::* )( char const *,int ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("nDefaultVal") ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (float ( ::ICommandLine::* )( char const *,float ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("flDefaultVal") ) )    
        .def( 
            "RemoveParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const * ) )(&::ICommandLine::RemoveParm) )
            , ( bp::arg("parm") ) )    
        .def( 
            "SetParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( int,char const * ) )(&::ICommandLine::SetParm) )
            , ( bp::arg("nIndex"), bp::arg("pNewParm") ) );

    bp::class_< PyConCommand >( "ConCommand", bp::init< char const *, bp::object, bp::optional< char const *, int, bp::object, bool > >(( bp::arg("pName"), bp::arg("method"), bp::arg("helpstring")=bp::object(), bp::arg("flags")=(int)(0), bp::arg("completionfunc")=boost::python::object(), bp::arg("useweakref")=(bool)(false) )) )    
        .def( 
            "CanAutoComplete"
            , (bool ( ::PyConCommand::* )(  ) )( &::PyConCommand::CanAutoComplete ) )    
        .def( 
            "Shutdown"
            , (void ( ::PyConCommand::* )(  ) )( &::PyConCommand::Shutdown ) );

    bp::class_< PyConVar >( "ConVar", bp::init< char const *, char const *, bp::optional< int > >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags")=(int)(0) )) )    
        .def( bp::init< char const *, char const *, int, char const * >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bool, float, bool, float >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("bMin"), bp::arg("fMin"), bp::arg("bMax"), bp::arg("fMax") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bp::object >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("callback") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bool, float, bool, float, bp::object >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("bMin"), bp::arg("fMin"), bp::arg("bMax"), bp::arg("fMax"), bp::arg("callback") )) )    
        .def( 
            "AddFlags"
            , (void ( ::ConVar::* )( int ) )( &::ConVar::AddFlags )
            , ( bp::arg("flags") ) )    
        .def( 
            "GetBool"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::GetBool ) )    
        .def( 
            "GetDefault"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetDefault ) )    
        .def( 
            "GetFloat"
            , (float ( ::ConVar::* )(  ) const)( &::ConVar::GetFloat ) )    
        .def( 
            "GetHelpText"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetHelpText ) )    
        .def( 
            "GetInt"
            , (int ( ::ConVar::* )(  ) const)( &::ConVar::GetInt ) )    
        .def( 
            "GetMax"
            , (bool ( ::ConVar::* )( float & ) const)( &::ConVar::GetMax )
            , ( bp::arg("maxVal") ) )    
        .def( 
            "GetMin"
            , (bool ( ::ConVar::* )( float & ) const)( &::ConVar::GetMin )
            , ( bp::arg("minVal") ) )    
        .def( 
            "GetName"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetName ) )    
        .def( 
            "GetString"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetString ) )    
        .def( 
            "IsCommand"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::IsCommand ) )    
        .def( 
            "IsFlagSet"
            , (bool ( ::ConVar::* )( int ) const)( &::ConVar::IsFlagSet )
            , ( bp::arg("flag") ) )    
        .def( 
            "IsRegistered"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::IsRegistered ) )    
        .def( 
            "Revert"
            , (void ( ::ConVar::* )(  ) )( &::ConVar::Revert ) );

    { //::PyGameEvent
        typedef bp::class_< PyGameEvent > GameEvent_exposer_t;
        GameEvent_exposer_t GameEvent_exposer = GameEvent_exposer_t( "GameEvent", bp::init< >() );
        bp::scope GameEvent_scope( GameEvent_exposer );
        GameEvent_exposer.def( bp::init< char const *, bp::optional< bool > >(( bp::arg("event_name"), bp::arg("force")=(bool)(false) )) );
        bp::implicitly_convertible< char const *, PyGameEvent >();
        { //::PyGameEvent::GetBool
        
            typedef bool ( ::PyGameEvent::*GetBool_function_type )( char const *,bool ) ;
            
            GameEvent_exposer.def( 
                "GetBool"
                , GetBool_function_type( &::PyGameEvent::GetBool )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=(bool)(false) ) );
        
        }
        { //::PyGameEvent::GetFloat
        
            typedef float ( ::PyGameEvent::*GetFloat_function_type )( char const *,float ) ;
            
            GameEvent_exposer.def( 
                "GetFloat"
                , GetFloat_function_type( &::PyGameEvent::GetFloat )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=0.0f ) );
        
        }
        { //::PyGameEvent::GetInt
        
            typedef int ( ::PyGameEvent::*GetInt_function_type )( char const *,int ) ;
            
            GameEvent_exposer.def( 
                "GetInt"
                , GetInt_function_type( &::PyGameEvent::GetInt )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=(int)(0) ) );
        
        }
        { //::PyGameEvent::GetName
        
            typedef char const * ( ::PyGameEvent::*GetName_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "GetName"
                , GetName_function_type( &::PyGameEvent::GetName ) );
        
        }
        { //::PyGameEvent::GetString
        
            typedef char const * ( ::PyGameEvent::*GetString_function_type )( char const *,char const * ) ;
            
            GameEvent_exposer.def( 
                "GetString"
                , GetString_function_type( &::PyGameEvent::GetString )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")="" ) );
        
        }
        { //::PyGameEvent::IsEmpty
        
            typedef bool ( ::PyGameEvent::*IsEmpty_function_type )( char const * ) ;
            
            GameEvent_exposer.def( 
                "IsEmpty"
                , IsEmpty_function_type( &::PyGameEvent::IsEmpty )
                , ( bp::arg("keyName")=bp::object() ) );
        
        }
        { //::PyGameEvent::IsLocal
        
            typedef bool ( ::PyGameEvent::*IsLocal_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "IsLocal"
                , IsLocal_function_type( &::PyGameEvent::IsLocal ) );
        
        }
        { //::PyGameEvent::IsReliable
        
            typedef bool ( ::PyGameEvent::*IsReliable_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "IsReliable"
                , IsReliable_function_type( &::PyGameEvent::IsReliable ) );
        
        }
        { //::PyGameEvent::SetBool
        
            typedef void ( ::PyGameEvent::*SetBool_function_type )( char const *,bool ) ;
            
            GameEvent_exposer.def( 
                "SetBool"
                , SetBool_function_type( &::PyGameEvent::SetBool )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetFloat
        
            typedef void ( ::PyGameEvent::*SetFloat_function_type )( char const *,float ) ;
            
            GameEvent_exposer.def( 
                "SetFloat"
                , SetFloat_function_type( &::PyGameEvent::SetFloat )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetInt
        
            typedef void ( ::PyGameEvent::*SetInt_function_type )( char const *,int ) ;
            
            GameEvent_exposer.def( 
                "SetInt"
                , SetInt_function_type( &::PyGameEvent::SetInt )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetString
        
            typedef void ( ::PyGameEvent::*SetString_function_type )( char const *,char const * ) ;
            
            GameEvent_exposer.def( 
                "SetString"
                , SetString_function_type( &::PyGameEvent::SetString )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
    }

    bp::class_< PyGameEventListener_wrapper >( "GameEventListener" )    
        .def( 
            "FireGameEvent"
            , (void ( ::PyGameEventListener::* )( ::boost::python::object ) )(&::PyGameEventListener::PyFireGameEvent)
            , (void ( PyGameEventListener_wrapper::* )( ::boost::python::object ) )(&PyGameEventListener_wrapper::default_FireGameEvent)
            , ( bp::arg("event") ) )    
        .def( "ListenForGameEvent", (void ( ::PyGameEventListener::* )( char const * ) )( &::PyGameEventListener::ListenForGameEvent ), bp::arg("name") )    
        .def( "StopListeningForAllEvents", (void ( ::PyGameEventListener::* )() )( &::PyGameEventListener::StopListeningForAllEvents ) );

    bp::class_< PyVEngineClient_wrapper >( "VEngineClient" )    
        .def( 
            "ActivateOccluder"
            , (void ( ::PyVEngineClient::* )( int,bool ) )( &::PyVEngineClient::ActivateOccluder )
            , ( bp::arg("nOccluderIndex"), bp::arg("bActive") ) )    
        .def( 
            "CheckDoneKeyTrapping"
            , (bool ( ::PyVEngineClient::* )( ::ButtonCode_t ) )( &::PyVEngineClient::CheckDoneKeyTrapping )
            , ( bp::arg("code") ) )    
        .def( 
            "CheckPoint"
            , (void ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::CheckPoint )
            , ( bp::arg("pName") ) )    
        .def( 
            "ClientCmd_Unrestricted"
            , (void ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::ClientCmd_Unrestricted )
            , ( bp::arg("szCmdString") ) )    
        .def( 
            "ClientCommand"
            , (void ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::ClientCommand )
            , ( bp::arg("szCmdString") ) )    
        .def( 
            "ComputeDynamicLighting"
            , (void ( ::PyVEngineClient::* )( ::Vector const &,::Vector const *,::Vector & ) )( &::PyVEngineClient::ComputeDynamicLighting )
            , ( bp::arg("pt"), bp::arg("pNormal"), bp::arg("color") ) )    
        .def( 
            "ComputeLighting"
            , (void ( ::PyVEngineClient::* )( ::Vector const &,::Vector const *,bool,::Vector &,::Vector * ) )( &::PyVEngineClient::ComputeLighting )
            , ( bp::arg("pt"), bp::arg("pNormal"), bp::arg("bClamp"), bp::arg("color"), bp::arg("pBoxColors")=bp::object() ) )    
        .def( 
            "Con_IsVisible"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::Con_IsVisible ) )    
        .def( 
            "Con_NPrintf"
            , (void ( ::PyVEngineClient::* )( int,char const * ) )( &::PyVEngineClient::Con_NPrintf )
            , ( bp::arg("pos"), bp::arg("fmt") ) )    
        .def( 
            "CopyFrameBufferToMaterial"
            , (bool ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::CopyFrameBufferToMaterial )
            , ( bp::arg("pMaterialName") ) )    
        .def( 
            "CullBox"
            , (bool ( ::PyVEngineClient::* )( ::Vector const &,::Vector const & ) )( &::PyVEngineClient::CullBox )
            , ( bp::arg("mins"), bp::arg("maxs") ) )    
        .def( 
            "DoesBoxTouchAreaFrustum"
            , (bool ( ::PyVEngineClient::* )( ::Vector const &,::Vector const &,int ) )( &::PyVEngineClient::DoesBoxTouchAreaFrustum )
            , ( bp::arg("mins"), bp::arg("maxs"), bp::arg("iArea") ) )    
        .def( 
            "DrawPortals"
            , (void ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::DrawPortals ) )    
        .def( 
            "ExecuteClientCmd"
            , (void ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::ExecuteClientCmd )
            , ( bp::arg("szCmdString") ) )    
        .def( 
            "GameLumpSize"
            , (int ( ::PyVEngineClient::* )( int ) const)( &::PyVEngineClient::GameLumpSize )
            , ( bp::arg("lumpId") ) )    
        .def( 
            "GameLumpVersion"
            , (int ( ::PyVEngineClient::* )( int ) const)( &::PyVEngineClient::GameLumpVersion )
            , ( bp::arg("lumpId") ) )    
        .def( 
            "GetAmbientLightColor"
            , (void ( ::PyVEngineClient::* )( ::Vector & ) )( &::PyVEngineClient::GetAmbientLightColor )
            , ( bp::arg("color") ) )    
        .def( 
            "GetAppID"
            , (int ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetAppID ) )    
        .def( 
            "GetChapterName"
            , (::boost::python::object ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetChapterName ) )    
        .def( 
            "GetDXSupportLevel"
            , (int ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetDXSupportLevel ) )    
        .def( 
            "GetEngineBuildNumber"
            , (unsigned int ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetEngineBuildNumber ) )    
        .def( 
            "GetGameDirectory"
            , (char const * ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetGameDirectory ) )    
        .def( 
            "GetLastTimeStamp"
            , (float ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetLastTimeStamp ) )    
        .def( 
            "GetLevelName"
            , (char const * ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetLevelName ) )    
        .def( 
            "GetLightForPoint"
            , (::Vector ( ::PyVEngineClient::* )( ::Vector const &,bool ) )(&::PyVEngineClient::GetLightForPoint)
            , (::Vector ( PyVEngineClient_wrapper::* )( ::Vector const &,bool ) )(&PyVEngineClient_wrapper::default_GetLightForPoint)
            , ( bp::arg("pos"), bp::arg("clamp") ) )    
        .def( 
            "GetLightForPointFast"
            , (::Vector ( ::PyVEngineClient::* )( ::Vector const &,bool ) )( &::PyVEngineClient::GetLightForPointFast )
            , ( bp::arg("pos"), bp::arg("bClamp") ) )    
        .def( 
            "GetLocalPlayer"
            , (int ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetLocalPlayer ) )    
        .def( 
            "GetMainMenuBackgroundName"
            , (::boost::python::object ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetMainMenuBackgroundName ) )    
        .def( 
            "GetMapEntitiesString"
            , (char const * ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetMapEntitiesString ) )    
        .def( 
            "GetMaxClients"
            , (int ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetMaxClients ) )    
        .def( 
            "GetMostRecentSaveGame"
            , (char const * ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetMostRecentSaveGame ) )    
        .def( 
            "GetPlayerForUserID"
            , (int ( ::PyVEngineClient::* )( int ) )( &::PyVEngineClient::GetPlayerForUserID )
            , ( bp::arg("userID") ) )    
        .def( 
            "GetPlayerInfo"
            , (bool ( ::PyVEngineClient::* )( int,::py_player_info_t * ) )( &::PyVEngineClient::GetPlayerInfo )
            , ( bp::arg("ent_num"), bp::arg("pinfo") ) )    
        .def( 
            "GetProductVersionString"
            , (char const * ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetProductVersionString ) )    
        .def( 
            "GetScreenAspectRatio"
            , (float ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetScreenAspectRatio ) )    
        .def( 
            "GetScreenSize"
            , (void ( ::PyVEngineClient::* )( int &,int & ) )( &::PyVEngineClient::GetScreenSize )
            , ( bp::arg("width"), bp::arg("height") ) )    
        .def( 
            "GetUILanguage"
            , (::boost::python::object ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::GetUILanguage ) )    
        .def( 
            "GetViewAngles"
            , (void ( ::PyVEngineClient::* )( ::QAngle & ) )( &::PyVEngineClient::GetViewAngles )
            , ( bp::arg("va") ) )    
        .def( 
            "GrabPreColorCorrectedFrame"
            , (void ( ::PyVEngineClient::* )( int,int,int,int ) )( &::PyVEngineClient::GrabPreColorCorrectedFrame )
            , ( bp::arg("x"), bp::arg("y"), bp::arg("width"), bp::arg("height") ) )    
        .def( 
            "IsBoxInViewCluster"
            , (int ( ::PyVEngineClient::* )( ::Vector const &,::Vector const & ) )( &::PyVEngineClient::IsBoxInViewCluster )
            , ( bp::arg("mins"), bp::arg("maxs") ) )    
        .def( 
            "IsBoxVisible"
            , (int ( ::PyVEngineClient::* )( ::Vector const &,::Vector const & ) )( &::PyVEngineClient::IsBoxVisible )
            , ( bp::arg("mins"), bp::arg("maxs") ) )    
        .def( 
            "IsConnected"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsConnected ) )    
        .def( 
            "IsDrawingLoadingImage"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsDrawingLoadingImage ) )    
        .def( 
            "IsHLTV"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsHLTV ) )    
        .def( 
            "IsHammerRunning"
            , (bool ( ::PyVEngineClient::* )(  ) const)( &::PyVEngineClient::IsHammerRunning ) )    
        .def( 
            "IsInEditMode"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsInEditMode ) )    
        .def( 
            "IsInGame"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsInGame ) )    
        .def( 
            "IsLevelMainMenuBackground"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsLevelMainMenuBackground ) )    
        .def( 
            "IsLowViolence"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsLowViolence ) )    
        .def( 
            "IsOccluded"
            , (bool ( ::PyVEngineClient::* )( ::Vector const &,::Vector const & ) )( &::PyVEngineClient::IsOccluded )
            , ( bp::arg("vecAbsMins"), bp::arg("vecAbsMaxs") ) )    
        .def( 
            "IsPaused"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsPaused ) )    
        .def( 
            "IsPlayingDemo"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsPlayingDemo ) )    
        .def( 
            "IsPlayingTimeDemo"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsPlayingTimeDemo ) )    
        .def( 
            "IsRecordingDemo"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsRecordingDemo ) )    
        .def( 
            "IsTakingScreenshot"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::IsTakingScreenshot ) )    
        .def( 
            "Key_BindingForKey"
            , (char const * ( ::PyVEngineClient::* )( ::ButtonCode_t ) )( &::PyVEngineClient::Key_BindingForKey )
            , ( bp::arg("code") ) )    
        .def( 
            "Key_LookupBinding"
            , (char const * ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::Key_LookupBinding )
            , ( bp::arg("pBinding") ) )    
        .def( 
            "LevelLeafCount"
            , (int ( ::PyVEngineClient::* )(  ) const)( &::PyVEngineClient::LevelLeafCount ) )    
        .def( 
            "LightStyleValue"
            , (float ( ::PyVEngineClient::* )( int ) )( &::PyVEngineClient::LightStyleValue )
            , ( bp::arg("style") ) )    
        .def( 
            "LoadModel"
            , (::model_t * ( ::PyVEngineClient::* )( char const *,bool ) )( &::PyVEngineClient::LoadModel )
            , ( bp::arg("pName"), bp::arg("bProp")=(bool)(false) )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "MapHasHDRLighting"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::MapHasHDRLighting ) )    
        .def( 
            "ReadConfiguration"
            , (void ( ::PyVEngineClient::* )( int const ) )( &::PyVEngineClient::ReadConfiguration )
            , ( bp::arg("iController") ) )    
        .def( 
            "ServerCommand"
            , (void ( ::PyVEngineClient::* )( char const *,bool ) )( &::PyVEngineClient::ServerCommand )
            , ( bp::arg("szCmdString"), bp::arg("bReliable")=(bool)(true) ) )    
        .def( 
            "SetMostRecentSaveGame"
            , (void ( ::PyVEngineClient::* )( char const * ) )( &::PyVEngineClient::SetMostRecentSaveGame )
            , ( bp::arg("lpszFilename") ) )    
        .def( 
            "SetRestrictClientCommands"
            , (void ( ::PyVEngineClient::* )( bool ) )( &::PyVEngineClient::SetRestrictClientCommands )
            , ( bp::arg("bRestrict") ) )    
        .def( 
            "SetRestrictServerCommands"
            , (void ( ::PyVEngineClient::* )( bool ) )( &::PyVEngineClient::SetRestrictServerCommands )
            , ( bp::arg("bRestrict") ) )    
        .def( 
            "SetViewAngles"
            , (void ( ::PyVEngineClient::* )( ::QAngle & ) )( &::PyVEngineClient::SetViewAngles )
            , ( bp::arg("va") ) )    
        .def( 
            "Sound_ExtraUpdate"
            , (void ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::Sound_ExtraUpdate ) )    
        .def( 
            "StartKeyTrapMode"
            , (void ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::StartKeyTrapMode ) )    
        .def( 
            "SupportsHDR"
            , (bool ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::SupportsHDR ) )    
        .def( 
            "WorldToScreenMatrix"
            , (::VMatrix const & ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::WorldToScreenMatrix )
            , bp::return_value_policy< bp::copy_const_reference >() )    
        .def( 
            "WorldToViewMatrix"
            , (::VMatrix const & ( ::PyVEngineClient::* )(  ) )( &::PyVEngineClient::WorldToViewMatrix )
            , bp::return_value_policy< bp::copy_const_reference >() );

    bp::class_< PyVModelInfo >( "VModelInfo" )    
        .def( 
            "FindOrLoadModel"
            , (::model_t * ( ::PyVModelInfo::* )( char const * ) )( &::PyVModelInfo::FindOrLoadModel )
            , ( bp::arg("name") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetModel"
            , (::model_t * ( ::PyVModelInfo::* )( int ) )( &::PyVModelInfo::GetModel )
            , ( bp::arg("modelindex") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetModelBounds"
            , (::boost::python::tuple ( ::PyVModelInfo::* )( ::model_t * ) )( &::PyVModelInfo::GetModelBounds )
            , ( bp::arg("pModel") ) )    
        .def( 
            "GetModelIndex"
            , (int ( ::PyVModelInfo::* )( char const * ) )( &::PyVModelInfo::GetModelIndex )
            , ( bp::arg("name") ) )    
        .def( 
            "GetModelName"
            , (::boost::python::object ( ::PyVModelInfo::* )( ::model_t * ) )( &::PyVModelInfo::GetModelName )
            , ( bp::arg("model") ) );

    { //::dheader_t
        typedef bp::class_< dheader_t_wrapper > dheader_t_exposer_t;
        dheader_t_exposer_t dheader_t_exposer = dheader_t_exposer_t( "dheader_t" );
        bp::scope dheader_t_scope( dheader_t_exposer );
        dheader_t_exposer.def_readwrite( "ident", &dheader_t::ident );
        pyplusplus::containers::static_sized::register_array_1< ::lump_t, 64, bp::return_internal_reference< > >( "__array_1__scope_lump_t_64" );
        { //dheader_t::lumps [variable], type=lump_t[64]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64> ( *array_wrapper_creator )( ::dheader_t & );
            
            dheader_t_exposer.add_property( "lumps"
                , bp::make_function( array_wrapper_creator(&dheader_t_wrapper::pyplusplus_lumps_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        dheader_t_exposer.def_readwrite( "mapRevision", &dheader_t::mapRevision );
        dheader_t_exposer.def_readwrite( "version", &dheader_t::version );
    }

    { //::lump_t
        typedef bp::class_< lump_t_wrapper > lump_t_exposer_t;
        lump_t_exposer_t lump_t_exposer = lump_t_exposer_t( "lump_t" );
        bp::scope lump_t_scope( lump_t_exposer );
        lump_t_exposer.def_readwrite( "filelen", &lump_t::filelen );
        lump_t_exposer.def_readwrite( "fileofs", &lump_t::fileofs );
        pyplusplus::containers::static_sized::register_array_1< char, 4 >( "__array_1_char_4" );
        { //lump_t::fourCC [variable], type=char[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 4> ( *array_wrapper_creator )( ::lump_t & );
            
            lump_t_exposer.add_property( "fourCC"
                , bp::make_function( array_wrapper_creator(&lump_t_wrapper::pyplusplus_fourCC_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        lump_t_exposer.def_readwrite( "version", &lump_t::version );
    }

    { //::py_player_info_s
        typedef bp::class_< py_player_info_s_wrapper > PlayerInfo_exposer_t;
        PlayerInfo_exposer_t PlayerInfo_exposer = PlayerInfo_exposer_t( "PlayerInfo" );
        bp::scope PlayerInfo_scope( PlayerInfo_exposer );
        pyplusplus::containers::static_sized::register_array_1< unsigned int, 4 >( "__array_1_unsigned_int_4" );
        { //py_player_info_s::customFiles [variable], type=CRC32_t[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< unsigned int, 4> ( *array_wrapper_creator )( ::py_player_info_s & );
            
            PlayerInfo_exposer.add_property( "customFiles"
                , bp::make_function( array_wrapper_creator(&py_player_info_s_wrapper::pyplusplus_customFiles_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PlayerInfo_exposer.def_readwrite( "fakeplayer", &py_player_info_s::fakeplayer );
        PlayerInfo_exposer.def_readwrite( "filesDownloaded", &py_player_info_s::filesDownloaded );
        PlayerInfo_exposer.def_readwrite( "friendsID", &py_player_info_s::friendsID );
        PlayerInfo_exposer.def_readwrite( "friendsName", &py_player_info_s::friendsName );
        PlayerInfo_exposer.def_readwrite( "guid", &py_player_info_s::guid );
        PlayerInfo_exposer.def_readwrite( "ishltv", &py_player_info_s::ishltv );
        PlayerInfo_exposer.def_readwrite( "name", &py_player_info_s::name );
        PlayerInfo_exposer.def_readwrite( "userID", &py_player_info_s::userID );
    }

    bp::class_< wrap_model_t >( "model_t", bp::no_init );

    { //::CommandLine_Tier0
    
        typedef ::ICommandLine * ( *CommandLine_function_type )(  );
        
        bp::def( 
            "CommandLine"
            , CommandLine_function_type( &::CommandLine_Tier0 )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::GetLevelName
    
        typedef char const * ( *GetLevelName_function_type )(  );
        
        bp::def( 
            "GetLevelName"
            , GetLevelName_function_type( &::GetLevelName ) );
    
    }

    { //::Plat_FloatTime
    
        typedef double ( *Plat_FloatTime_function_type )(  );
        
        bp::def( 
            "Plat_FloatTime"
            , Plat_FloatTime_function_type( &::Plat_FloatTime ) );
    
    }

    { //::Plat_MSTime
    
        typedef unsigned int ( *Plat_MSTime_function_type )(  );
        
        bp::def( 
            "Plat_MSTime"
            , Plat_MSTime_function_type( &::Plat_MSTime ) );
    
    }

    { //::PrecacheMaterial
    
        typedef void ( *PrecacheMaterial_function_type )( char const * );
        
        bp::def( 
            "PrecacheMaterial"
            , PrecacheMaterial_function_type( &::PrecacheMaterial )
            , ( bp::arg("pMaterialName") ) );
    
    }

    { //::PyAddSearchPath
    
        typedef void ( *AddSearchPath_function_type )( char const *,char const *,::SearchPathAdd_t );
        
        bp::def( 
            "AddSearchPath"
            , AddSearchPath_function_type( &::PyAddSearchPath )
            , ( bp::arg("pPath"), bp::arg("pathID"), bp::arg("addType")=::PATH_ADD_TO_TAIL ) );
    
    }

    { //::PyAsyncFinishAllWrites
    
        typedef void ( *AsyncFinishAllWrites_function_type )(  );
        
        bp::def( 
            "AsyncFinishAllWrites"
            , AsyncFinishAllWrites_function_type( &::PyAsyncFinishAllWrites ) );
    
    }

    { //::PyFireGameEventClientSide
    
        typedef void ( *FireGameEventClientSide_function_type )( ::PyGameEvent * );
        
        bp::def( 
            "FireGameEventClientSide"
            , FireGameEventClientSide_function_type( &::PyFireGameEventClientSide )
            , ( bp::arg("pEvent") ) );
    
    }

    { //::PyGetMapHeader
    
        typedef ::dheader_t ( *GetMapHeader_function_type )( char const * );
        
        bp::def( 
            "GetMapHeader"
            , GetMapHeader_function_type( &::PyGetMapHeader )
            , ( bp::arg("mapname") ) );
    
    }

    { //::PyGetModPath
    
        typedef ::boost::python::object ( *GetModPath_function_type )(  );
        
        bp::def( 
            "GetModPath"
            , GetModPath_function_type( &::PyGetModPath ) );
    
    }

    { //::PyGetSearchPath
    
        typedef ::boost::python::object ( *GetSearchPath_function_type )( char const *,bool );
        
        bp::def( 
            "GetSearchPath"
            , GetSearchPath_function_type( &::PyGetSearchPath )
            , ( bp::arg("pPathID"), bp::arg("bGetPackFiles") ) );
    
    }

    { //::PyRemoveSearchPath
    
        typedef bool ( *RemoveSearchPath_function_type )( char const *,char const * );
        
        bp::def( 
            "RemoveSearchPath"
            , RemoveSearchPath_function_type( &::PyRemoveSearchPath )
            , ( bp::arg("pPath"), bp::arg("pathID")=bp::object() ) );
    
    }

    { //::PyShutdownConCommand
    
        typedef bool ( *PyShutdownConCommand_function_type )( char const * );
        
        bp::def( 
            "PyShutdownConCommand"
            , PyShutdownConCommand_function_type( &::PyShutdownConCommand )
            , ( bp::arg("pName") ) );
    
    }

    bp::scope().attr( "engine" ) = boost::ref(pyengine);

    bp::scope().attr( "modelinfo" ) = boost::ref(pymodelinfo);

    ptr_model_t_to_wrap_model_t();

    const_ptr_model_t_to_wrap_model_t();

    wrap_model_t_to_model_t();

    bp::scope().attr( "LUMP_ENTITIES" ) = (int)LUMP_ENTITIES;

    bp::scope().attr( "FCVAR_NONE" ) = (int)FCVAR_NONE;

    bp::scope().attr( "FCVAR_UNREGISTERED" ) = (int)FCVAR_UNREGISTERED;

    bp::scope().attr( "FCVAR_DEVELOPMENTONLY" ) = (int)FCVAR_DEVELOPMENTONLY;

    bp::scope().attr( "FCVAR_GAMEDLL" ) = (int)FCVAR_GAMEDLL;

    bp::scope().attr( "FCVAR_CLIENTDLL" ) = (int)FCVAR_CLIENTDLL;

    bp::scope().attr( "FCVAR_HIDDEN" ) = (int)FCVAR_HIDDEN;

    bp::scope().attr( "FCVAR_PROTECTED" ) = (int)FCVAR_PROTECTED;

    bp::scope().attr( "FCVAR_SPONLY" ) = (int)FCVAR_SPONLY;

    bp::scope().attr( "FCVAR_ARCHIVE" ) = (int)FCVAR_ARCHIVE;

    bp::scope().attr( "FCVAR_NOTIFY" ) = (int)FCVAR_NOTIFY;

    bp::scope().attr( "FCVAR_USERINFO" ) = (int)FCVAR_USERINFO;

    bp::scope().attr( "FCVAR_CHEAT" ) = (int)FCVAR_CHEAT;

    bp::scope().attr( "FCVAR_PRINTABLEONLY" ) = (int)FCVAR_PRINTABLEONLY;

    bp::scope().attr( "FCVAR_UNLOGGED" ) = (int)FCVAR_UNLOGGED;

    bp::scope().attr( "FCVAR_NEVER_AS_STRING" ) = (int)FCVAR_NEVER_AS_STRING;

    bp::scope().attr( "FCVAR_REPLICATED" ) = (int)FCVAR_REPLICATED;

    bp::scope().attr( "FCVAR_DEMO" ) = (int)FCVAR_DEMO;

    bp::scope().attr( "FCVAR_DONTRECORD" ) = (int)FCVAR_DONTRECORD;

    bp::scope().attr( "FCVAR_NOT_CONNECTED" ) = (int)FCVAR_NOT_CONNECTED;

    bp::scope().attr( "FCVAR_ARCHIVE_XBOX" ) = (int)FCVAR_ARCHIVE_XBOX;

    bp::scope().attr( "FCVAR_SERVER_CAN_EXECUTE" ) = (int)FCVAR_SERVER_CAN_EXECUTE;

    bp::scope().attr( "FCVAR_SERVER_CANNOT_QUERY" ) = (int)FCVAR_SERVER_CANNOT_QUERY;

    bp::scope().attr( "FCVAR_CLIENTCMD_CAN_EXECUTE" ) = (int)FCVAR_CLIENTCMD_CAN_EXECUTE;

    { //::PyShutdownConVar
    
        typedef bool ( *PyShutdownConVar_function_type )( char const * );
        
        bp::def( 
            "PyShutdownConVar"
            , PyShutdownConVar_function_type( &::PyShutdownConVar )
            , ( bp::arg("pName") ) );
    
    }
}
#else
#include "__array_1.pypp.hpp"

#include "cbase.h"

#include "mathlib/vmatrix.h"

#include "utlvector.h"

#include "shareddefs.h"

#include "util.h"

#include "iservernetworkable.h"

#include "recipientfilter.h"

#include "srcpy_usermessage.h"

#include "mapentities.h"

#include "tier0/icommandline.h"

#include "convar.h"

#include "igameevents.h"

#include "irecipientfilter.h"

#include "srcpy_gameinterface.h"

#include "cdll_int.h"

#include "srcpy_gameinterface_converters.h"

#include "srcpy.h"

#include "tier0/memdbgon.h"

namespace bp = boost::python;

struct CBaseGameSystem_wrapper : CBaseGameSystem, bp::wrapper< CBaseGameSystem > {

    CBaseGameSystem_wrapper(CBaseGameSystem const & arg )
    : CBaseGameSystem( arg )
      , bp::wrapper< CBaseGameSystem >(){
        // copy constructor
        
    }

    CBaseGameSystem_wrapper()
    : CBaseGameSystem()
      , bp::wrapper< CBaseGameSystem >(){
        // null constructor
        
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Init(  );
            }
        else
            return this->CBaseGameSystem::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystem::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystem::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystem::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystem::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystem::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystem::LevelShutdownPreEntity( );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Name(  );
            }
        else
            return this->CBaseGameSystem::Name(  );
    }
    
    char const * default_Name(  ) {
        return CBaseGameSystem::Name( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnRestore(  );
            }
        else
            this->CBaseGameSystem::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystem::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnSave(  );
            }
        else
            this->CBaseGameSystem::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystem::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::PostInit(  );
            }
        else
            this->CBaseGameSystem::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystem::PostInit( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::Shutdown(  );
            }
        else
            this->CBaseGameSystem::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystem::Shutdown( );
    }

};

struct CAutoGameSystem_wrapper : CAutoGameSystem, bp::wrapper< CAutoGameSystem > {

    CAutoGameSystem_wrapper(CAutoGameSystem const & arg )
    : CAutoGameSystem( arg )
      , bp::wrapper< CAutoGameSystem >(){
        // copy constructor
        
    }

    CAutoGameSystem_wrapper(char const * name=0 )
    : CAutoGameSystem( name )
      , bp::wrapper< CAutoGameSystem >(){
        // constructor
    
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CAutoGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAutoGameSystem::Name(  );
            }
        else
            return this->CAutoGameSystem::Name(  );
    }
    
    char const * default_Name(  ) {
        return CAutoGameSystem::Name( );
    }

    static ::CAutoGameSystem * get_m_pNext(CAutoGameSystem const & inst ){
        return inst.m_pNext;
    }
    
    static void set_m_pNext( CAutoGameSystem & inst, ::CAutoGameSystem * new_value ){ 
        inst.m_pNext = new_value;
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystem::Init(  );
            }
        else
            return this->CBaseGameSystem::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystem::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystem::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystem::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystem::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystem::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystem::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystem::LevelShutdownPreEntity( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnRestore(  );
            }
        else
            this->CBaseGameSystem::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystem::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::OnSave(  );
            }
        else
            this->CBaseGameSystem::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystem::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::PostInit(  );
            }
        else
            this->CBaseGameSystem::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystem::PostInit( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystem\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystem::Shutdown(  );
            }
        else
            this->CBaseGameSystem::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystem::Shutdown( );
    }

};

struct CBaseGameSystemPerFrame_wrapper : CBaseGameSystemPerFrame, bp::wrapper< CBaseGameSystemPerFrame > {

    CBaseGameSystemPerFrame_wrapper(CBaseGameSystemPerFrame const & arg )
    : CBaseGameSystemPerFrame( arg )
      , bp::wrapper< CBaseGameSystemPerFrame >(){
        // copy constructor
        
    }

    CBaseGameSystemPerFrame_wrapper()
    : CBaseGameSystemPerFrame()
      , bp::wrapper< CBaseGameSystemPerFrame >(){
        // null constructor
        
    }

    virtual void FrameUpdatePostEntityThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FrameUpdatePostEntityThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FrameUpdatePostEntityThink(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FrameUpdatePostEntityThink = this->get_override( "FrameUpdatePostEntityThink" );
        if( func_FrameUpdatePostEntityThink.ptr() != Py_None )
            try {
                func_FrameUpdatePostEntityThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::FrameUpdatePostEntityThink(  );
            }
        else
            this->CBaseGameSystemPerFrame::FrameUpdatePostEntityThink(  );
    }
    
    void default_FrameUpdatePostEntityThink(  ) {
        CBaseGameSystemPerFrame::FrameUpdatePostEntityThink( );
    }

    virtual void FrameUpdatePreEntityThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FrameUpdatePreEntityThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FrameUpdatePreEntityThink(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FrameUpdatePreEntityThink = this->get_override( "FrameUpdatePreEntityThink" );
        if( func_FrameUpdatePreEntityThink.ptr() != Py_None )
            try {
                func_FrameUpdatePreEntityThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::FrameUpdatePreEntityThink(  );
            }
        else
            this->CBaseGameSystemPerFrame::FrameUpdatePreEntityThink(  );
    }
    
    void default_FrameUpdatePreEntityThink(  ) {
        CBaseGameSystemPerFrame::FrameUpdatePreEntityThink( );
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Init(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystemPerFrame::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreEntity( );
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Name(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Name(  );
    }
    
    char const * default_Name(  ) {
        return CBaseGameSystemPerFrame::Name( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnRestore(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystemPerFrame::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnSave(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystemPerFrame::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostInit(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystemPerFrame::PostInit( );
    }

    virtual void PreClientUpdate(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PreClientUpdate: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PreClientUpdate(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PreClientUpdate = this->get_override( "PreClientUpdate" );
        if( func_PreClientUpdate.ptr() != Py_None )
            try {
                func_PreClientUpdate(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PreClientUpdate(  );
            }
        else
            this->CBaseGameSystemPerFrame::PreClientUpdate(  );
    }
    
    void default_PreClientUpdate(  ) {
        CBaseGameSystemPerFrame::PreClientUpdate( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Shutdown(  );
            }
        else
            this->CBaseGameSystemPerFrame::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystemPerFrame::Shutdown( );
    }

};

struct CAutoGameSystemPerFrame_wrapper : CAutoGameSystemPerFrame, bp::wrapper< CAutoGameSystemPerFrame > {

    CAutoGameSystemPerFrame_wrapper(CAutoGameSystemPerFrame const & arg )
    : CAutoGameSystemPerFrame( arg )
      , bp::wrapper< CAutoGameSystemPerFrame >(){
        // copy constructor
        
    }

    CAutoGameSystemPerFrame_wrapper(char const * name=0 )
    : CAutoGameSystemPerFrame( name )
      , bp::wrapper< CAutoGameSystemPerFrame >(){
        // constructor
    
    }

    virtual char const * Name(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Name: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Name(  ) of Class: CAutoGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Name = this->get_override( "Name" );
        if( func_Name.ptr() != Py_None )
            try {
                return func_Name(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CAutoGameSystemPerFrame::Name(  );
            }
        else
            return this->CAutoGameSystemPerFrame::Name(  );
    }
    
    char const * default_Name(  ) {
        return CAutoGameSystemPerFrame::Name( );
    }

    static ::CAutoGameSystemPerFrame * get_m_pNext(CAutoGameSystemPerFrame const & inst ){
        return inst.m_pNext;
    }
    
    static void set_m_pNext( CAutoGameSystemPerFrame & inst, ::CAutoGameSystemPerFrame * new_value ){ 
        inst.m_pNext = new_value;
    }

    virtual void FrameUpdatePostEntityThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FrameUpdatePostEntityThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FrameUpdatePostEntityThink(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FrameUpdatePostEntityThink = this->get_override( "FrameUpdatePostEntityThink" );
        if( func_FrameUpdatePostEntityThink.ptr() != Py_None )
            try {
                func_FrameUpdatePostEntityThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::FrameUpdatePostEntityThink(  );
            }
        else
            this->CBaseGameSystemPerFrame::FrameUpdatePostEntityThink(  );
    }
    
    void default_FrameUpdatePostEntityThink(  ) {
        CBaseGameSystemPerFrame::FrameUpdatePostEntityThink( );
    }

    virtual void FrameUpdatePreEntityThink(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FrameUpdatePreEntityThink: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling FrameUpdatePreEntityThink(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FrameUpdatePreEntityThink = this->get_override( "FrameUpdatePreEntityThink" );
        if( func_FrameUpdatePreEntityThink.ptr() != Py_None )
            try {
                func_FrameUpdatePreEntityThink(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::FrameUpdatePreEntityThink(  );
            }
        else
            this->CBaseGameSystemPerFrame::FrameUpdatePreEntityThink(  );
    }
    
    void default_FrameUpdatePreEntityThink(  ) {
        CBaseGameSystemPerFrame::FrameUpdatePreEntityThink( );
    }

    virtual bool Init(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Init: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Init(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Init = this->get_override( "Init" );
        if( func_Init.ptr() != Py_None )
            try {
                return func_Init(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                return this->CBaseGameSystemPerFrame::Init(  );
            }
        else
            return this->CBaseGameSystemPerFrame::Init(  );
    }
    
    bool default_Init(  ) {
        return CBaseGameSystemPerFrame::Init( );
    }

    virtual void LevelInitPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPostEntity = this->get_override( "LevelInitPostEntity" );
        if( func_LevelInitPostEntity.ptr() != Py_None )
            try {
                func_LevelInitPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPostEntity(  );
    }
    
    void default_LevelInitPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPostEntity( );
    }

    virtual void LevelInitPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelInitPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelInitPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelInitPreEntity = this->get_override( "LevelInitPreEntity" );
        if( func_LevelInitPreEntity.ptr() != Py_None )
            try {
                func_LevelInitPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelInitPreEntity(  );
    }
    
    void default_LevelInitPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelInitPreEntity( );
    }

    virtual void LevelShutdownPostEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPostEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPostEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPostEntity = this->get_override( "LevelShutdownPostEntity" );
        if( func_LevelShutdownPostEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPostEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPostEntity(  );
    }
    
    void default_LevelShutdownPostEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPostEntity( );
    }

    virtual void LevelShutdownPreClearSteamAPIContext(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreClearSteamAPIContext: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreClearSteamAPIContext(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreClearSteamAPIContext = this->get_override( "LevelShutdownPreClearSteamAPIContext" );
        if( func_LevelShutdownPreClearSteamAPIContext.ptr() != Py_None )
            try {
                func_LevelShutdownPreClearSteamAPIContext(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext(  );
    }
    
    void default_LevelShutdownPreClearSteamAPIContext(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext( );
    }

    virtual void LevelShutdownPreEntity(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "LevelShutdownPreEntity: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling LevelShutdownPreEntity(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_LevelShutdownPreEntity = this->get_override( "LevelShutdownPreEntity" );
        if( func_LevelShutdownPreEntity.ptr() != Py_None )
            try {
                func_LevelShutdownPreEntity(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
            }
        else
            this->CBaseGameSystemPerFrame::LevelShutdownPreEntity(  );
    }
    
    void default_LevelShutdownPreEntity(  ) {
        CBaseGameSystemPerFrame::LevelShutdownPreEntity( );
    }

    virtual void OnRestore(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnRestore: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnRestore(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnRestore = this->get_override( "OnRestore" );
        if( func_OnRestore.ptr() != Py_None )
            try {
                func_OnRestore(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnRestore(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnRestore(  );
    }
    
    void default_OnRestore(  ) {
        CBaseGameSystemPerFrame::OnRestore( );
    }

    virtual void OnSave(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "OnSave: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling OnSave(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_OnSave = this->get_override( "OnSave" );
        if( func_OnSave.ptr() != Py_None )
            try {
                func_OnSave(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::OnSave(  );
            }
        else
            this->CBaseGameSystemPerFrame::OnSave(  );
    }
    
    void default_OnSave(  ) {
        CBaseGameSystemPerFrame::OnSave( );
    }

    virtual void PostInit(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PostInit: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PostInit(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PostInit = this->get_override( "PostInit" );
        if( func_PostInit.ptr() != Py_None )
            try {
                func_PostInit(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PostInit(  );
            }
        else
            this->CBaseGameSystemPerFrame::PostInit(  );
    }
    
    void default_PostInit(  ) {
        CBaseGameSystemPerFrame::PostInit( );
    }

    virtual void PreClientUpdate(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "PreClientUpdate: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PreClientUpdate(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_PreClientUpdate = this->get_override( "PreClientUpdate" );
        if( func_PreClientUpdate.ptr() != Py_None )
            try {
                func_PreClientUpdate(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::PreClientUpdate(  );
            }
        else
            this->CBaseGameSystemPerFrame::PreClientUpdate(  );
    }
    
    void default_PreClientUpdate(  ) {
        CBaseGameSystemPerFrame::PreClientUpdate( );
    }

    virtual void Shutdown(  ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "Shutdown: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling Shutdown(  ) of Class: CBaseGameSystemPerFrame\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_Shutdown = this->get_override( "Shutdown" );
        if( func_Shutdown.ptr() != Py_None )
            try {
                func_Shutdown(  );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->CBaseGameSystemPerFrame::Shutdown(  );
            }
        else
            this->CBaseGameSystemPerFrame::Shutdown(  );
    }
    
    void default_Shutdown(  ) {
        CBaseGameSystemPerFrame::Shutdown( );
    }

};

struct ICommandLine_wrapper : ICommandLine, bp::wrapper< ICommandLine > {

    ICommandLine_wrapper()
    : ICommandLine()
      , bp::wrapper< ICommandLine >(){
        // null constructor
        
    }

    virtual void AppendParm( char const * pszParm, char const * pszValues ){
        bp::override func_AppendParm = this->get_override( "AppendParm" );
        try {
            func_AppendParm( pszParm, pszValues );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * CheckParm( char const * psz, char const * * ppszValue=0 ) const {
        bp::override func_CheckParm = this->get_override( "CheckParm" );
        try {
            return func_CheckParm( psz, ppszValue );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void CreateCmdLine( char const * commandline ){
        bp::override func_CreateCmdLine = this->get_override( "CreateCmdLine" );
        try {
            func_CreateCmdLine( commandline );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void CreateCmdLine( int argc, char * * argv ){
        bp::override func_CreateCmdLine = this->get_override( "CreateCmdLine" );
        try {
            func_CreateCmdLine( argc, argv );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int FindParm( char const * psz ) const {
        bp::override func_FindParm = this->get_override( "FindParm" );
        try {
            return func_FindParm( psz );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * GetCmdLine(  ) const {
        bp::override func_GetCmdLine = this->get_override( "GetCmdLine" );
        try {
            return func_GetCmdLine(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * GetParm( int nIndex ) const {
        bp::override func_GetParm = this->get_override( "GetParm" );
        try {
            return func_GetParm( nIndex );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int ParmCount(  ) const {
        bp::override func_ParmCount = this->get_override( "ParmCount" );
        try {
            return func_ParmCount(  );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual char const * ParmValue( char const * psz, char const * pDefaultVal=0 ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, pDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual int ParmValue( char const * psz, int nDefaultVal ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, nDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual float ParmValue( char const * psz, float flDefaultVal ) const {
        bp::override func_ParmValue = this->get_override( "ParmValue" );
        try {
            return func_ParmValue( psz, flDefaultVal );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void RemoveParm( char const * parm ){
        bp::override func_RemoveParm = this->get_override( "RemoveParm" );
        try {
            func_RemoveParm( parm );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual void SetParm( int nIndex, char const * pNewParm ){
        bp::override func_SetParm = this->get_override( "SetParm" );
        try {
            func_SetParm( nIndex, pNewParm );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

};

struct IMapEntityFilter_wrapper : IMapEntityFilter, bp::wrapper< IMapEntityFilter > {

    IMapEntityFilter_wrapper()
    : IMapEntityFilter()
      , bp::wrapper< IMapEntityFilter >(){
        // null constructor
        
    }

    virtual ::CBaseEntity * CreateNextEntity( char const * pClassname ){
        bp::override func_CreateNextEntity = this->get_override( "CreateNextEntity" );
        try {
            return func_CreateNextEntity( pClassname );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

    virtual bool ShouldCreateEntity( char const * pClassname ){
        bp::override func_ShouldCreateEntity = this->get_override( "ShouldCreateEntity" );
        try {
            return func_ShouldCreateEntity( pClassname );
        } catch(bp::error_already_set &) {
            throw boost::python::error_already_set();
        }
    }

};

struct PyGameEventListener_wrapper : PyGameEventListener, bp::wrapper< PyGameEventListener > {

    PyGameEventListener_wrapper(PyGameEventListener const & arg )
    : PyGameEventListener( arg )
      , bp::wrapper< PyGameEventListener >(){
        // copy constructor
        
    }

    PyGameEventListener_wrapper()
    : PyGameEventListener()
      , bp::wrapper< PyGameEventListener >(){
        // null constructor
        
    }

    virtual void PyFireGameEvent( ::boost::python::object event ) {
        #if defined(_WIN32)
        #if defined(_DEBUG)
        Assert( SrcPySystem()->IsPythonRunning() );
        Assert( GetCurrentThreadId() == g_hPythonThreadID );
        #elif defined(PY_CHECKTHREADID)
        if( GetCurrentThreadId() != g_hPythonThreadID )
            Error( "FireGameEvent: Client? %d. Thread ID is not the same as in which the python interpreter is initialized! %d != %d. Tell a developer.\n", CBaseEntity::IsClient(), g_hPythonThreadID, GetCurrentThreadId() );
        #endif // _DEBUG/PY_CHECKTHREADID
        #endif // _WIN32
        #if defined(_DEBUG) || defined(PY_CHECK_LOG_OVERRIDES)
        if( py_log_overrides.GetBool() )
            Msg("Calling PyFireGameEvent( event ) of Class: PyGameEventListener\n");
        #endif // _DEBUG/PY_CHECK_LOG_OVERRIDES
        bp::override func_FireGameEvent = this->get_override( "FireGameEvent" );
        if( func_FireGameEvent.ptr() != Py_None )
            try {
                func_FireGameEvent( event );
            } catch(bp::error_already_set &) {
                PyErr_Print();
                this->PyGameEventListener::PyFireGameEvent( event );
            }
        else
            this->PyGameEventListener::PyFireGameEvent( event );
    }
    
    void default_FireGameEvent( ::boost::python::object event ) {
        PyGameEventListener::PyFireGameEvent( event );
    }

};

struct dheader_t_wrapper : dheader_t, bp::wrapper< dheader_t > {

    dheader_t_wrapper(dheader_t const & arg )
    : dheader_t( arg )
      , bp::wrapper< dheader_t >(){
        // copy constructor
        
    }

    dheader_t_wrapper()
    : dheader_t()
      , bp::wrapper< dheader_t >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64>
    pyplusplus_lumps_wrapper( ::dheader_t & inst ){
        return pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64>( inst.lumps );
    }

};

struct lump_t_wrapper : lump_t, bp::wrapper< lump_t > {

    lump_t_wrapper(lump_t const & arg )
    : lump_t( arg )
      , bp::wrapper< lump_t >(){
        // copy constructor
        
    }

    lump_t_wrapper()
    : lump_t()
      , bp::wrapper< lump_t >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< char, 4>
    pyplusplus_fourCC_wrapper( ::lump_t & inst ){
        return pyplusplus::containers::static_sized::array_1_t< char, 4>( inst.fourCC );
    }

};

struct py_player_info_s_wrapper : py_player_info_s, bp::wrapper< py_player_info_s > {

    py_player_info_s_wrapper(py_player_info_s const & arg )
    : py_player_info_s( arg )
      , bp::wrapper< py_player_info_s >(){
        // copy constructor
        
    }

    py_player_info_s_wrapper()
    : py_player_info_s()
      , bp::wrapper< py_player_info_s >(){
        // null constructor
        
    }

    static pyplusplus::containers::static_sized::array_1_t< unsigned int, 4>
    pyplusplus_customFiles_wrapper( ::py_player_info_s & inst ){
        return pyplusplus::containers::static_sized::array_1_t< unsigned int, 4>( inst.customFiles );
    }

};

BOOST_PYTHON_MODULE(_gameinterface){
    bp::docstring_options doc_options( true, true, false );

    bp::enum_< FilesystemMountRetval_t>("FilesystemMountRetval_t")
        .value("FILESYSTEM_MOUNT_OK", FILESYSTEM_MOUNT_OK)
        .value("FILESYSTEM_MOUNT_FAILED", FILESYSTEM_MOUNT_FAILED)
        .export_values()
        ;

    bp::enum_< SearchPathAdd_t>("SearchPathAdd_t")
        .value("PATH_ADD_TO_HEAD", PATH_ADD_TO_HEAD)
        .value("PATH_ADD_TO_TAIL", PATH_ADD_TO_TAIL)
        .export_values()
        ;

    bp::class_< IGameSystem, boost::noncopyable >( "IGameSystem", bp::no_init )    
        .def( 
            "Add"
            , (void (*)( ::IGameSystem * ))( &::IGameSystem::Add )
            , ( bp::arg("pSys") ) )    
        .def( 
            "FrameUpdatePostEntityThinkAllSystems"
            , (void (*)(  ))( &::IGameSystem::FrameUpdatePostEntityThinkAllSystems ) )    
        .def( 
            "FrameUpdatePreEntityThinkAllSystems"
            , (void (*)(  ))( &::IGameSystem::FrameUpdatePreEntityThinkAllSystems ) )    
        .def( 
            "Init"
            , (bool ( ::IGameSystem::* )(  ) )( &::IGameSystem::Init ) )    
        .def( 
            "InitAllSystems"
            , (bool (*)(  ))( &::IGameSystem::InitAllSystems ) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::IGameSystem::* )(  ) )( &::IGameSystem::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelInitPostEntity ) )    
        .def( 
            "LevelInitPostEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelInitPostEntityAllSystems ) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelInitPreEntity ) )    
        .def( 
            "LevelInitPreEntityAllSystems"
            , (void (*)( char const * ))( &::IGameSystem::LevelInitPreEntityAllSystems )
            , ( bp::arg("pMapName") ) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPostEntity ) )    
        .def( 
            "LevelShutdownPostEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPostEntityAllSystems ) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPreClearSteamAPIContext ) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContextAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPreClearSteamAPIContextAllSystems ) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::LevelShutdownPreEntity ) )    
        .def( 
            "LevelShutdownPreEntityAllSystems"
            , (void (*)(  ))( &::IGameSystem::LevelShutdownPreEntityAllSystems ) )    
        .def( 
            "MapName"
            , (char const * (*)(  ))( &::IGameSystem::MapName ) )    
        .def( 
            "Name"
            , (char const * ( ::IGameSystem::* )(  ) )( &::IGameSystem::Name ) )    
        .def( 
            "OnRestore"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::OnRestore ) )    
        .def( 
            "OnRestoreAllSystems"
            , (void (*)(  ))( &::IGameSystem::OnRestoreAllSystems ) )    
        .def( 
            "OnSave"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::OnSave ) )    
        .def( 
            "OnSaveAllSystems"
            , (void (*)(  ))( &::IGameSystem::OnSaveAllSystems ) )    
        .def( 
            "PostInit"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::PostInit ) )    
        .def( 
            "PostInitAllSystems"
            , (void (*)(  ))( &::IGameSystem::PostInitAllSystems ) )    
        .def( 
            "PreClientUpdateAllSystems"
            , (void (*)(  ))( &::IGameSystem::PreClientUpdateAllSystems ) )    
        .def( 
            "Remove"
            , (void (*)( ::IGameSystem * ))( &::IGameSystem::Remove )
            , ( bp::arg("pSys") ) )    
        .def( 
            "RemoveAll"
            , (void (*)(  ))( &::IGameSystem::RemoveAll ) )    
        .def( 
            "RunCommandPlayer"
            , (::CBasePlayer * (*)(  ))( &::IGameSystem::RunCommandPlayer )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "RunCommandUserCmd"
            , (::CUserCmd * (*)(  ))( &::IGameSystem::RunCommandUserCmd )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::SafeRemoveIfDesired ) )    
        .def( 
            "SafeRemoveIfDesiredAllSystems"
            , (void (*)(  ))( &::IGameSystem::SafeRemoveIfDesiredAllSystems ) )    
        .def( 
            "Shutdown"
            , (void ( ::IGameSystem::* )(  ) )( &::IGameSystem::Shutdown ) )    
        .def( 
            "ShutdownAllSystems"
            , (void (*)(  ))( &::IGameSystem::ShutdownAllSystems ) )    
        .staticmethod( "Add" )    
        .staticmethod( "FrameUpdatePostEntityThinkAllSystems" )    
        .staticmethod( "FrameUpdatePreEntityThinkAllSystems" )    
        .staticmethod( "InitAllSystems" )    
        .staticmethod( "LevelInitPostEntityAllSystems" )    
        .staticmethod( "LevelInitPreEntityAllSystems" )    
        .staticmethod( "LevelShutdownPostEntityAllSystems" )    
        .staticmethod( "LevelShutdownPreClearSteamAPIContextAllSystems" )    
        .staticmethod( "LevelShutdownPreEntityAllSystems" )    
        .staticmethod( "MapName" )    
        .staticmethod( "OnRestoreAllSystems" )    
        .staticmethod( "OnSaveAllSystems" )    
        .staticmethod( "PostInitAllSystems" )    
        .staticmethod( "PreClientUpdateAllSystems" )    
        .staticmethod( "Remove" )    
        .staticmethod( "RemoveAll" )    
        .staticmethod( "RunCommandPlayer" )    
        .staticmethod( "RunCommandUserCmd" )    
        .staticmethod( "SafeRemoveIfDesiredAllSystems" )    
        .staticmethod( "ShutdownAllSystems" );

    bp::class_< CBaseGameSystem_wrapper, bp::bases< IGameSystem > >( "CBaseGameSystem" )    
        .def( 
            "Init"
            , (bool ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Init)
            , (bool ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Init) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::CBaseGameSystem::* )(  ) )( &::CBaseGameSystem::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelInitPostEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelInitPostEntity) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelInitPreEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelInitPreEntity) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPostEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPostEntity) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPreClearSteamAPIContext) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::LevelShutdownPreEntity)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_LevelShutdownPreEntity) )    
        .def( 
            "Name"
            , (char const * ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Name)
            , (char const * ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Name) )    
        .def( 
            "OnRestore"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::OnRestore)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_OnRestore) )    
        .def( 
            "OnSave"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::OnSave)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_OnSave) )    
        .def( 
            "PostInit"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::PostInit)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_PostInit) )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::CBaseGameSystem::* )(  ) )( &::CBaseGameSystem::SafeRemoveIfDesired ) )    
        .def( 
            "Shutdown"
            , (void ( ::CBaseGameSystem::* )(  ) )(&::CBaseGameSystem::Shutdown)
            , (void ( CBaseGameSystem_wrapper::* )(  ) )(&CBaseGameSystem_wrapper::default_Shutdown) );

    { //::CAutoGameSystem
        typedef bp::class_< CAutoGameSystem_wrapper, bp::bases< CBaseGameSystem > > AutoGameSystem_exposer_t;
        AutoGameSystem_exposer_t AutoGameSystem_exposer = AutoGameSystem_exposer_t( "AutoGameSystem", bp::init< bp::optional< char const * > >(( bp::arg("name")=bp::object() )) );
        bp::scope AutoGameSystem_scope( AutoGameSystem_exposer );
        bp::implicitly_convertible< char const *, CAutoGameSystem >();
        { //::CAutoGameSystem::Name
        
            typedef char const * ( ::CAutoGameSystem::*Name_function_type )(  ) ;
            typedef char const * ( CAutoGameSystem_wrapper::*default_Name_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Name"
                , Name_function_type(&::CAutoGameSystem::Name)
                , default_Name_function_type(&CAutoGameSystem_wrapper::default_Name) );
        
        }
        AutoGameSystem_exposer.add_property( "m_pNext"
                    , bp::make_function( (::CAutoGameSystem * (*)( ::CAutoGameSystem const & ))(&CAutoGameSystem_wrapper::get_m_pNext), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::CAutoGameSystem &,::CAutoGameSystem * ))(&CAutoGameSystem_wrapper::set_m_pNext), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        { //::CBaseGameSystem::Init
        
            typedef bool ( ::CBaseGameSystem::*Init_function_type )(  ) ;
            typedef bool ( CAutoGameSystem_wrapper::*default_Init_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Init"
                , Init_function_type(&::CBaseGameSystem::Init)
                , default_Init_function_type(&CAutoGameSystem_wrapper::default_Init) );
        
        }
        { //::CBaseGameSystem::LevelInitPostEntity
        
            typedef void ( ::CBaseGameSystem::*LevelInitPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelInitPostEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelInitPostEntity"
                , LevelInitPostEntity_function_type(&::CBaseGameSystem::LevelInitPostEntity)
                , default_LevelInitPostEntity_function_type(&CAutoGameSystem_wrapper::default_LevelInitPostEntity) );
        
        }
        { //::CBaseGameSystem::LevelInitPreEntity
        
            typedef void ( ::CBaseGameSystem::*LevelInitPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelInitPreEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelInitPreEntity"
                , LevelInitPreEntity_function_type(&::CBaseGameSystem::LevelInitPreEntity)
                , default_LevelInitPreEntity_function_type(&CAutoGameSystem_wrapper::default_LevelInitPreEntity) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPostEntity
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPostEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPostEntity"
                , LevelShutdownPostEntity_function_type(&::CBaseGameSystem::LevelShutdownPostEntity)
                , default_LevelShutdownPostEntity_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPostEntity) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPreClearSteamAPIContext"
                , LevelShutdownPreClearSteamAPIContext_function_type(&::CBaseGameSystem::LevelShutdownPreClearSteamAPIContext)
                , default_LevelShutdownPreClearSteamAPIContext_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPreClearSteamAPIContext) );
        
        }
        { //::CBaseGameSystem::LevelShutdownPreEntity
        
            typedef void ( ::CBaseGameSystem::*LevelShutdownPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_LevelShutdownPreEntity_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "LevelShutdownPreEntity"
                , LevelShutdownPreEntity_function_type(&::CBaseGameSystem::LevelShutdownPreEntity)
                , default_LevelShutdownPreEntity_function_type(&CAutoGameSystem_wrapper::default_LevelShutdownPreEntity) );
        
        }
        { //::CBaseGameSystem::OnRestore
        
            typedef void ( ::CBaseGameSystem::*OnRestore_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_OnRestore_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "OnRestore"
                , OnRestore_function_type(&::CBaseGameSystem::OnRestore)
                , default_OnRestore_function_type(&CAutoGameSystem_wrapper::default_OnRestore) );
        
        }
        { //::CBaseGameSystem::OnSave
        
            typedef void ( ::CBaseGameSystem::*OnSave_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_OnSave_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "OnSave"
                , OnSave_function_type(&::CBaseGameSystem::OnSave)
                , default_OnSave_function_type(&CAutoGameSystem_wrapper::default_OnSave) );
        
        }
        { //::CBaseGameSystem::PostInit
        
            typedef void ( ::CBaseGameSystem::*PostInit_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_PostInit_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "PostInit"
                , PostInit_function_type(&::CBaseGameSystem::PostInit)
                , default_PostInit_function_type(&CAutoGameSystem_wrapper::default_PostInit) );
        
        }
        { //::CBaseGameSystem::Shutdown
        
            typedef void ( ::CBaseGameSystem::*Shutdown_function_type )(  ) ;
            typedef void ( CAutoGameSystem_wrapper::*default_Shutdown_function_type )(  ) ;
            
            AutoGameSystem_exposer.def( 
                "Shutdown"
                , Shutdown_function_type(&::CBaseGameSystem::Shutdown)
                , default_Shutdown_function_type(&CAutoGameSystem_wrapper::default_Shutdown) );
        
        }
    }

    bp::class_< CBaseGameSystemPerFrame_wrapper >( "CBaseGameSystemPerFrame" )    
        .def( 
            "FrameUpdatePostEntityThink"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::FrameUpdatePostEntityThink)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_FrameUpdatePostEntityThink) )    
        .def( 
            "FrameUpdatePreEntityThink"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::FrameUpdatePreEntityThink)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_FrameUpdatePreEntityThink) )    
        .def( 
            "Init"
            , (bool ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Init)
            , (bool ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Init) )    
        .def( 
            "IsPerFrame"
            , (bool ( ::CBaseGameSystemPerFrame::* )(  ) )( &::CBaseGameSystemPerFrame::IsPerFrame ) )    
        .def( 
            "LevelInitPostEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelInitPostEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelInitPostEntity) )    
        .def( 
            "LevelInitPreEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelInitPreEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelInitPreEntity) )    
        .def( 
            "LevelShutdownPostEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPostEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPostEntity) )    
        .def( 
            "LevelShutdownPreClearSteamAPIContext"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPreClearSteamAPIContext) )    
        .def( 
            "LevelShutdownPreEntity"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::LevelShutdownPreEntity)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_LevelShutdownPreEntity) )    
        .def( 
            "Name"
            , (char const * ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Name)
            , (char const * ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Name) )    
        .def( 
            "OnRestore"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::OnRestore)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_OnRestore) )    
        .def( 
            "OnSave"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::OnSave)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_OnSave) )    
        .def( 
            "PostInit"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::PostInit)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_PostInit) )    
        .def( 
            "PreClientUpdate"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::PreClientUpdate)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_PreClientUpdate) )    
        .def( 
            "SafeRemoveIfDesired"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )( &::CBaseGameSystemPerFrame::SafeRemoveIfDesired ) )    
        .def( 
            "Shutdown"
            , (void ( ::CBaseGameSystemPerFrame::* )(  ) )(&::CBaseGameSystemPerFrame::Shutdown)
            , (void ( CBaseGameSystemPerFrame_wrapper::* )(  ) )(&CBaseGameSystemPerFrame_wrapper::default_Shutdown) );

    { //::CAutoGameSystemPerFrame
        typedef bp::class_< CAutoGameSystemPerFrame_wrapper, bp::bases< CBaseGameSystemPerFrame > > AutoGameSystemPerFrame_exposer_t;
        AutoGameSystemPerFrame_exposer_t AutoGameSystemPerFrame_exposer = AutoGameSystemPerFrame_exposer_t( "AutoGameSystemPerFrame", bp::init< bp::optional< char const * > >(( bp::arg("name")=bp::object() )) );
        bp::scope AutoGameSystemPerFrame_scope( AutoGameSystemPerFrame_exposer );
        bp::implicitly_convertible< char const *, CAutoGameSystemPerFrame >();
        { //::CAutoGameSystemPerFrame::Name
        
            typedef char const * ( ::CAutoGameSystemPerFrame::*Name_function_type )(  ) ;
            typedef char const * ( CAutoGameSystemPerFrame_wrapper::*default_Name_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Name"
                , Name_function_type(&::CAutoGameSystemPerFrame::Name)
                , default_Name_function_type(&CAutoGameSystemPerFrame_wrapper::default_Name) );
        
        }
        AutoGameSystemPerFrame_exposer.add_property( "m_pNext"
                    , bp::make_function( (::CAutoGameSystemPerFrame * (*)( ::CAutoGameSystemPerFrame const & ))(&CAutoGameSystemPerFrame_wrapper::get_m_pNext), bp::return_internal_reference< >() )
                    , bp::make_function( (void (*)( ::CAutoGameSystemPerFrame &,::CAutoGameSystemPerFrame * ))(&CAutoGameSystemPerFrame_wrapper::set_m_pNext), bp::with_custodian_and_ward_postcall< 1, 2 >() ) );
        { //::CBaseGameSystemPerFrame::FrameUpdatePostEntityThink
        
            typedef void ( ::CBaseGameSystemPerFrame::*FrameUpdatePostEntityThink_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_FrameUpdatePostEntityThink_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "FrameUpdatePostEntityThink"
                , FrameUpdatePostEntityThink_function_type(&::CBaseGameSystemPerFrame::FrameUpdatePostEntityThink)
                , default_FrameUpdatePostEntityThink_function_type(&CAutoGameSystemPerFrame_wrapper::default_FrameUpdatePostEntityThink) );
        
        }
        { //::CBaseGameSystemPerFrame::FrameUpdatePreEntityThink
        
            typedef void ( ::CBaseGameSystemPerFrame::*FrameUpdatePreEntityThink_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_FrameUpdatePreEntityThink_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "FrameUpdatePreEntityThink"
                , FrameUpdatePreEntityThink_function_type(&::CBaseGameSystemPerFrame::FrameUpdatePreEntityThink)
                , default_FrameUpdatePreEntityThink_function_type(&CAutoGameSystemPerFrame_wrapper::default_FrameUpdatePreEntityThink) );
        
        }
        { //::CBaseGameSystemPerFrame::Init
        
            typedef bool ( ::CBaseGameSystemPerFrame::*Init_function_type )(  ) ;
            typedef bool ( CAutoGameSystemPerFrame_wrapper::*default_Init_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Init"
                , Init_function_type(&::CBaseGameSystemPerFrame::Init)
                , default_Init_function_type(&CAutoGameSystemPerFrame_wrapper::default_Init) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelInitPostEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelInitPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelInitPostEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelInitPostEntity"
                , LevelInitPostEntity_function_type(&::CBaseGameSystemPerFrame::LevelInitPostEntity)
                , default_LevelInitPostEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelInitPostEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelInitPreEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelInitPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelInitPreEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelInitPreEntity"
                , LevelInitPreEntity_function_type(&::CBaseGameSystemPerFrame::LevelInitPreEntity)
                , default_LevelInitPreEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelInitPreEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPostEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPostEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPostEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPostEntity"
                , LevelShutdownPostEntity_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPostEntity)
                , default_LevelShutdownPostEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPostEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPreClearSteamAPIContext_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPreClearSteamAPIContext"
                , LevelShutdownPreClearSteamAPIContext_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPreClearSteamAPIContext)
                , default_LevelShutdownPreClearSteamAPIContext_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPreClearSteamAPIContext) );
        
        }
        { //::CBaseGameSystemPerFrame::LevelShutdownPreEntity
        
            typedef void ( ::CBaseGameSystemPerFrame::*LevelShutdownPreEntity_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_LevelShutdownPreEntity_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "LevelShutdownPreEntity"
                , LevelShutdownPreEntity_function_type(&::CBaseGameSystemPerFrame::LevelShutdownPreEntity)
                , default_LevelShutdownPreEntity_function_type(&CAutoGameSystemPerFrame_wrapper::default_LevelShutdownPreEntity) );
        
        }
        { //::CBaseGameSystemPerFrame::OnRestore
        
            typedef void ( ::CBaseGameSystemPerFrame::*OnRestore_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_OnRestore_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "OnRestore"
                , OnRestore_function_type(&::CBaseGameSystemPerFrame::OnRestore)
                , default_OnRestore_function_type(&CAutoGameSystemPerFrame_wrapper::default_OnRestore) );
        
        }
        { //::CBaseGameSystemPerFrame::OnSave
        
            typedef void ( ::CBaseGameSystemPerFrame::*OnSave_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_OnSave_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "OnSave"
                , OnSave_function_type(&::CBaseGameSystemPerFrame::OnSave)
                , default_OnSave_function_type(&CAutoGameSystemPerFrame_wrapper::default_OnSave) );
        
        }
        { //::CBaseGameSystemPerFrame::PostInit
        
            typedef void ( ::CBaseGameSystemPerFrame::*PostInit_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_PostInit_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "PostInit"
                , PostInit_function_type(&::CBaseGameSystemPerFrame::PostInit)
                , default_PostInit_function_type(&CAutoGameSystemPerFrame_wrapper::default_PostInit) );
        
        }
        { //::CBaseGameSystemPerFrame::PreClientUpdate
        
            typedef void ( ::CBaseGameSystemPerFrame::*PreClientUpdate_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_PreClientUpdate_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "PreClientUpdate"
                , PreClientUpdate_function_type(&::CBaseGameSystemPerFrame::PreClientUpdate)
                , default_PreClientUpdate_function_type(&CAutoGameSystemPerFrame_wrapper::default_PreClientUpdate) );
        
        }
        { //::CBaseGameSystemPerFrame::Shutdown
        
            typedef void ( ::CBaseGameSystemPerFrame::*Shutdown_function_type )(  ) ;
            typedef void ( CAutoGameSystemPerFrame_wrapper::*default_Shutdown_function_type )(  ) ;
            
            AutoGameSystemPerFrame_exposer.def( 
                "Shutdown"
                , Shutdown_function_type(&::CBaseGameSystemPerFrame::Shutdown)
                , default_Shutdown_function_type(&CAutoGameSystemPerFrame_wrapper::default_Shutdown) );
        
        }
    }

    bp::class_< IRecipientFilter, boost::noncopyable >( "IRecipientFilter", bp::no_init )    
        .def( 
            "GetRecipientCount"
            , (int ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::GetRecipientCount ) )    
        .def( 
            "GetRecipientIndex"
            , (int ( ::IRecipientFilter::* )( int ) const)( &::IRecipientFilter::GetRecipientIndex )
            , ( bp::arg("slot") ) )    
        .def( 
            "IsInitMessage"
            , (bool ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::IsInitMessage ) )    
        .def( 
            "IsReliable"
            , (bool ( ::IRecipientFilter::* )(  ) const)( &::IRecipientFilter::IsReliable ) );

    bp::class_< CRecipientFilter, bp::bases< IRecipientFilter >, boost::noncopyable >( "CRecipientFilter", bp::no_init )    
        .def( bp::init< >() )    
        .def( 
            "AddAllPlayers"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::AddAllPlayers ) )    
        .def( 
            "AddPlayersFromBitMask"
            , (void ( ::CRecipientFilter::* )( ::CBitVec< 255 > & ) )( &::CRecipientFilter::AddPlayersFromBitMask )
            , ( bp::arg("playerbits") ) )    
        .def( 
            "AddRecipient"
            , (void ( ::CRecipientFilter::* )( ::CBasePlayer * ) )( &::CRecipientFilter::AddRecipient )
            , ( bp::arg("player") ) )    
        .def( 
            "AddRecipientsByPAS"
            , (void ( ::CRecipientFilter::* )( ::Vector const & ) )( &::CRecipientFilter::AddRecipientsByPAS )
            , ( bp::arg("origin") ) )    
        .def( 
            "AddRecipientsByPVS"
            , (void ( ::CRecipientFilter::* )( ::Vector const & ) )( &::CRecipientFilter::AddRecipientsByPVS )
            , ( bp::arg("origin") ) )    
        .def( 
            "AddRecipientsByTeam"
            , (void ( ::CRecipientFilter::* )( ::CTeam * ) )( &::CRecipientFilter::AddRecipientsByTeam )
            , ( bp::arg("team") ) )    
        .def( 
            "CopyFrom"
            , (void ( ::CRecipientFilter::* )( ::CRecipientFilter const & ) )( &::CRecipientFilter::CopyFrom )
            , ( bp::arg("src") ) )    
        .def( 
            "GetRecipientCount"
            , (int ( ::CRecipientFilter::* )(  ) const)( &::CRecipientFilter::GetRecipientCount ) )    
        .def( 
            "GetRecipientIndex"
            , (int ( ::CRecipientFilter::* )( int ) const)( &::CRecipientFilter::GetRecipientIndex )
            , ( bp::arg("slot") ) )    
        .def( 
            "IgnorePredictionCull"
            , (bool ( ::CRecipientFilter::* )(  ) const)( &::CRecipientFilter::IgnorePredictionCull ) )    
        .def( 
            "IsInitMessage"
            , (bool ( ::CRecipientFilter::* )(  ) const)( &::CRecipientFilter::IsInitMessage ) )    
        .def( 
            "IsReliable"
            , (bool ( ::CRecipientFilter::* )(  ) const)( &::CRecipientFilter::IsReliable ) )    
        .def( 
            "IsUsingPredictionRules"
            , (bool ( ::CRecipientFilter::* )(  ) const)( &::CRecipientFilter::IsUsingPredictionRules ) )    
        .def( 
            "MakeInitMessage"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::MakeInitMessage ) )    
        .def( 
            "MakeReliable"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::MakeReliable ) )    
        .def( 
            "RemoveAllRecipients"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::RemoveAllRecipients ) )    
        .def( 
            "RemovePlayersFromBitMask"
            , (void ( ::CRecipientFilter::* )( ::CBitVec< 255 > & ) )( &::CRecipientFilter::RemovePlayersFromBitMask )
            , ( bp::arg("playerbits") ) )    
        .def( 
            "RemoveRecipient"
            , (void ( ::CRecipientFilter::* )( ::CBasePlayer * ) )( &::CRecipientFilter::RemoveRecipient )
            , ( bp::arg("player") ) )    
        .def( 
            "RemoveRecipientByPlayerIndex"
            , (void ( ::CRecipientFilter::* )( int ) )( &::CRecipientFilter::RemoveRecipientByPlayerIndex )
            , ( bp::arg("playerindex") ) )    
        .def( 
            "RemoveRecipientsByPVS"
            , (void ( ::CRecipientFilter::* )( ::Vector const & ) )( &::CRecipientFilter::RemoveRecipientsByPVS )
            , ( bp::arg("origin") ) )    
        .def( 
            "RemoveRecipientsByTeam"
            , (void ( ::CRecipientFilter::* )( ::CTeam * ) )( &::CRecipientFilter::RemoveRecipientsByTeam )
            , ( bp::arg("team") ) )    
        .def( 
            "RemoveRecipientsNotOnTeam"
            , (void ( ::CRecipientFilter::* )( ::CTeam * ) )( &::CRecipientFilter::RemoveRecipientsNotOnTeam )
            , ( bp::arg("team") ) )    
        .def( 
            "Reset"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::Reset ) )    
        .def( 
            "SetIgnorePredictionCull"
            , (void ( ::CRecipientFilter::* )( bool ) )( &::CRecipientFilter::SetIgnorePredictionCull )
            , ( bp::arg("ignore") ) )    
        .def( 
            "UsePredictionRules"
            , (void ( ::CRecipientFilter::* )(  ) )( &::CRecipientFilter::UsePredictionRules ) );

    bp::class_< CBroadcastRecipientFilter, bp::bases< CRecipientFilter >, boost::noncopyable >( "CBroadcastRecipientFilter", bp::init< >() );

    bp::class_< CCommand >( "CCommand", bp::init< >() )    
        .def( bp::init< int, char const * * >(( bp::arg("nArgC"), bp::arg("ppArgV") )) )    
        .def( 
            "Arg"
            , (char const * ( ::CCommand::* )( int ) const)( &::CCommand::Arg )
            , ( bp::arg("nIndex") ) )    
        .def( 
            "ArgC"
            , (int ( ::CCommand::* )(  ) const)( &::CCommand::ArgC ) )    
        .def( 
            "ArgS"
            , (char const * ( ::CCommand::* )(  ) const)( &::CCommand::ArgS ) )    
        .def( 
            "FindArg"
            , (char const * ( ::CCommand::* )( char const * ) const)( &::CCommand::FindArg )
            , ( bp::arg("pName") ) )    
        .def( 
            "FindArgInt"
            , (int ( ::CCommand::* )( char const *,int ) const)( &::CCommand::FindArgInt )
            , ( bp::arg("pName"), bp::arg("nDefaultVal") ) )    
        .def( 
            "GetCommandString"
            , (char const * ( ::CCommand::* )(  ) const)( &::CCommand::GetCommandString ) )    
        .def( 
            "MaxCommandLength"
            , (int (*)(  ))( &::CCommand::MaxCommandLength ) )    
        .def( 
            "Reset"
            , (void ( ::CCommand::* )(  ) )( &::CCommand::Reset ) )    
        .def( 
            "__getitem__"
            , (char const * ( ::CCommand::* )( int ) const)( &::CCommand::operator[] )
            , ( bp::arg("nIndex") ) )    
        .staticmethod( "MaxCommandLength" )    
        .def( 
            "__len__"
            , (int ( ::CCommand::* )(  ) const)( &::CCommand::ArgC ) );

    bp::class_< CMapEntityRef >( "CMapEntityRef" )    
        .def_readwrite( "m_iEdict", &CMapEntityRef::m_iEdict )    
        .def_readwrite( "m_iSerialNumber", &CMapEntityRef::m_iSerialNumber );

    { //::CPASFilter
        typedef bp::class_< CPASFilter, bp::bases< CRecipientFilter >, boost::noncopyable > CPASFilter_exposer_t;
        CPASFilter_exposer_t CPASFilter_exposer = CPASFilter_exposer_t( "CPASFilter", bp::init< >() );
        bp::scope CPASFilter_scope( CPASFilter_exposer );
        CPASFilter_exposer.def( bp::init< Vector const & >(( bp::arg("origin") )) );
        bp::implicitly_convertible< Vector const &, CPASFilter >();
    }

    { //::CPASAttenuationFilter
        typedef bp::class_< CPASAttenuationFilter, bp::bases< CPASFilter >, boost::noncopyable > CPASAttenuationFilter_exposer_t;
        CPASAttenuationFilter_exposer_t CPASAttenuationFilter_exposer = CPASAttenuationFilter_exposer_t( "CPASAttenuationFilter", bp::init< >() );
        bp::scope CPASAttenuationFilter_scope( CPASAttenuationFilter_exposer );
        CPASAttenuationFilter_exposer.def( bp::init< CBaseEntity *, soundlevel_t >(( bp::arg("entity"), bp::arg("soundlevel") )) );
        CPASAttenuationFilter_exposer.def( bp::init< CBaseEntity *, bp::optional< float > >(( bp::arg("entity"), bp::arg("attenuation")=8.00000011920928955078125e-1f )) );
        bp::implicitly_convertible< CBaseEntity *, CPASAttenuationFilter >();
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, soundlevel_t >(( bp::arg("origin"), bp::arg("soundlevel") )) );
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, bp::optional< float > >(( bp::arg("origin"), bp::arg("attenuation")=8.00000011920928955078125e-1f )) );
        bp::implicitly_convertible< Vector const &, CPASAttenuationFilter >();
        CPASAttenuationFilter_exposer.def( bp::init< CBaseEntity *, char const * >(( bp::arg("entity"), bp::arg("lookupSound") )) );
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, char const * >(( bp::arg("origin"), bp::arg("lookupSound") )) );
        CPASAttenuationFilter_exposer.def( bp::init< CBaseEntity *, char const *, HSOUNDSCRIPTHANDLE & >(( bp::arg("entity"), bp::arg("lookupSound"), bp::arg("handle") )) );
        CPASAttenuationFilter_exposer.def( bp::init< Vector const &, char const *, HSOUNDSCRIPTHANDLE & >(( bp::arg("origin"), bp::arg("lookupSound"), bp::arg("handle") )) );
        { //::CPASAttenuationFilter::Filter
        
            typedef void ( ::CPASAttenuationFilter::*Filter_function_type )( ::Vector const &,float ) ;
            
            CPASAttenuationFilter_exposer.def( 
                "Filter"
                , Filter_function_type( &::CPASAttenuationFilter::Filter )
                , ( bp::arg("origin"), bp::arg("attenuation")=8.00000011920928955078125e-1f ) );
        
        }
    }

    { //::CPVSFilter
        typedef bp::class_< CPVSFilter, bp::bases< CRecipientFilter >, boost::noncopyable > CPVSFilter_exposer_t;
        CPVSFilter_exposer_t CPVSFilter_exposer = CPVSFilter_exposer_t( "CPVSFilter", bp::init< Vector const & >(( bp::arg("origin") )) );
        bp::scope CPVSFilter_scope( CPVSFilter_exposer );
        bp::implicitly_convertible< Vector const &, CPVSFilter >();
    }

    bp::class_< CReliableBroadcastRecipientFilter, bp::bases< CBroadcastRecipientFilter >, boost::noncopyable >( "CReliableBroadcastRecipientFilter", bp::init< >() );

    { //::CSingleUserRecipientFilter
        typedef bp::class_< CSingleUserRecipientFilter, bp::bases< CRecipientFilter >, boost::noncopyable > CSingleUserRecipientFilter_exposer_t;
        CSingleUserRecipientFilter_exposer_t CSingleUserRecipientFilter_exposer = CSingleUserRecipientFilter_exposer_t( "CSingleUserRecipientFilter", bp::init< CBasePlayer * >(( bp::arg("player") )) );
        bp::scope CSingleUserRecipientFilter_scope( CSingleUserRecipientFilter_exposer );
        bp::implicitly_convertible< CBasePlayer *, CSingleUserRecipientFilter >();
    }

    { //::ConVarRef
        typedef bp::class_< ConVarRef > ConVarRef_exposer_t;
        ConVarRef_exposer_t ConVarRef_exposer = ConVarRef_exposer_t( "ConVarRef", bp::init< char const * >(( bp::arg("pName") )) );
        bp::scope ConVarRef_scope( ConVarRef_exposer );
        bp::implicitly_convertible< char const *, ConVarRef >();
        ConVarRef_exposer.def( bp::init< char const *, bool >(( bp::arg("pName"), bp::arg("bIgnoreMissing") )) );
        ConVarRef_exposer.def( bp::init< IConVar * >(( bp::arg("pConVar") )) );
        bp::implicitly_convertible< IConVar *, ConVarRef >();
        { //::ConVarRef::GetBool
        
            typedef bool ( ::ConVarRef::*GetBool_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetBool"
                , GetBool_function_type( &::ConVarRef::GetBool ) );
        
        }
        { //::ConVarRef::GetDefault
        
            typedef char const * ( ::ConVarRef::*GetDefault_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetDefault"
                , GetDefault_function_type( &::ConVarRef::GetDefault ) );
        
        }
        { //::ConVarRef::GetFloat
        
            typedef float ( ::ConVarRef::*GetFloat_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetFloat"
                , GetFloat_function_type( &::ConVarRef::GetFloat ) );
        
        }
        { //::ConVarRef::GetInt
        
            typedef int ( ::ConVarRef::*GetInt_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetInt"
                , GetInt_function_type( &::ConVarRef::GetInt ) );
        
        }
        { //::ConVarRef::GetName
        
            typedef char const * ( ::ConVarRef::*GetName_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetName"
                , GetName_function_type( &::ConVarRef::GetName ) );
        
        }
        { //::ConVarRef::GetString
        
            typedef char const * ( ::ConVarRef::*GetString_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "GetString"
                , GetString_function_type( &::ConVarRef::GetString ) );
        
        }
        { //::ConVarRef::Init
        
            typedef void ( ::ConVarRef::*Init_function_type )( char const *,bool ) ;
            
            ConVarRef_exposer.def( 
                "Init"
                , Init_function_type( &::ConVarRef::Init )
                , ( bp::arg("pName"), bp::arg("bIgnoreMissing") ) );
        
        }
        { //::ConVarRef::IsFlagSet
        
            typedef bool ( ::ConVarRef::*IsFlagSet_function_type )( int ) const;
            
            ConVarRef_exposer.def( 
                "IsFlagSet"
                , IsFlagSet_function_type( &::ConVarRef::IsFlagSet )
                , ( bp::arg("nFlags") ) );
        
        }
        { //::ConVarRef::IsValid
        
            typedef bool ( ::ConVarRef::*IsValid_function_type )(  ) const;
            
            ConVarRef_exposer.def( 
                "IsValid"
                , IsValid_function_type( &::ConVarRef::IsValid ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( char const * ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("pValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( float ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("flValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( int ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("nValue") ) );
        
        }
        { //::ConVarRef::SetValue
        
            typedef void ( ::ConVarRef::*SetValue_function_type )( bool ) ;
            
            ConVarRef_exposer.def( 
                "SetValue"
                , SetValue_function_type( &::ConVarRef::SetValue )
                , ( bp::arg("bValue") ) );
        
        }
    }

    bp::class_< ICommandLine_wrapper, boost::noncopyable >( "ICommandLine" )    
        .def( 
            "AppendParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const *,char const * ) )(&::ICommandLine::AppendParm) )
            , ( bp::arg("pszParm"), bp::arg("pszValues") ) )    
        .def( 
            "CheckParm"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( char const *,char const * * ) const)(&::ICommandLine::CheckParm) )
            , ( bp::arg("psz"), bp::arg("ppszValue")=bp::object() ) )    
        .def( 
            "CreateCmdLine"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const * ) )(&::ICommandLine::CreateCmdLine) )
            , ( bp::arg("commandline") ) )    
        .def( 
            "CreateCmdLine"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( int,char * * ) )(&::ICommandLine::CreateCmdLine) )
            , ( bp::arg("argc"), bp::arg("argv") ) )    
        .def( 
            "FindParm"
            , bp::pure_virtual( (int ( ::ICommandLine::* )( char const * ) const)(&::ICommandLine::FindParm) )
            , ( bp::arg("psz") ) )    
        .def( 
            "GetCmdLine"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )(  ) const)(&::ICommandLine::GetCmdLine) ) )    
        .def( 
            "GetParm"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( int ) const)(&::ICommandLine::GetParm) )
            , ( bp::arg("nIndex") ) )    
        .def( 
            "ParmCount"
            , bp::pure_virtual( (int ( ::ICommandLine::* )(  ) const)(&::ICommandLine::ParmCount) ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (char const * ( ::ICommandLine::* )( char const *,char const * ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("pDefaultVal")=bp::object() ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (int ( ::ICommandLine::* )( char const *,int ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("nDefaultVal") ) )    
        .def( 
            "ParmValue"
            , bp::pure_virtual( (float ( ::ICommandLine::* )( char const *,float ) const)(&::ICommandLine::ParmValue) )
            , ( bp::arg("psz"), bp::arg("flDefaultVal") ) )    
        .def( 
            "RemoveParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( char const * ) )(&::ICommandLine::RemoveParm) )
            , ( bp::arg("parm") ) )    
        .def( 
            "SetParm"
            , bp::pure_virtual( (void ( ::ICommandLine::* )( int,char const * ) )(&::ICommandLine::SetParm) )
            , ( bp::arg("nIndex"), bp::arg("pNewParm") ) );

    bp::class_< IMapEntityFilter_wrapper, boost::noncopyable >( "IMapEntityFilter" )    
        .def( 
            "CreateNextEntity"
            , bp::pure_virtual( (::CBaseEntity * ( ::IMapEntityFilter::* )( char const * ) )(&::IMapEntityFilter::CreateNextEntity) )
            , ( bp::arg("pClassname") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "ShouldCreateEntity"
            , bp::pure_virtual( (bool ( ::IMapEntityFilter::* )( char const * ) )(&::IMapEntityFilter::ShouldCreateEntity) )
            , ( bp::arg("pClassname") ) );

    bp::class_< PyConCommand >( "ConCommand", bp::init< char const *, bp::object, bp::optional< char const *, int, bp::object, bool > >(( bp::arg("pName"), bp::arg("method"), bp::arg("helpstring")=bp::object(), bp::arg("flags")=(int)(0), bp::arg("completionfunc")=boost::python::object(), bp::arg("useweakref")=(bool)(false) )) )    
        .def( 
            "CanAutoComplete"
            , (bool ( ::PyConCommand::* )(  ) )( &::PyConCommand::CanAutoComplete ) )    
        .def( 
            "Shutdown"
            , (void ( ::PyConCommand::* )(  ) )( &::PyConCommand::Shutdown ) );

    bp::class_< PyConVar >( "ConVar", bp::init< char const *, char const *, bp::optional< int > >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags")=(int)(0) )) )    
        .def( bp::init< char const *, char const *, int, char const * >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bool, float, bool, float >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("bMin"), bp::arg("fMin"), bp::arg("bMax"), bp::arg("fMax") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bp::object >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("callback") )) )    
        .def( bp::init< char const *, char const *, int, char const *, bool, float, bool, float, bp::object >(( bp::arg("name"), bp::arg("defaultvalue"), bp::arg("flags"), bp::arg("helpstring"), bp::arg("bMin"), bp::arg("fMin"), bp::arg("bMax"), bp::arg("fMax"), bp::arg("callback") )) )    
        .def( 
            "AddFlags"
            , (void ( ::ConVar::* )( int ) )( &::ConVar::AddFlags )
            , ( bp::arg("flags") ) )    
        .def( 
            "GetBool"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::GetBool ) )    
        .def( 
            "GetDefault"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetDefault ) )    
        .def( 
            "GetFloat"
            , (float ( ::ConVar::* )(  ) const)( &::ConVar::GetFloat ) )    
        .def( 
            "GetHelpText"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetHelpText ) )    
        .def( 
            "GetInt"
            , (int ( ::ConVar::* )(  ) const)( &::ConVar::GetInt ) )    
        .def( 
            "GetMax"
            , (bool ( ::ConVar::* )( float & ) const)( &::ConVar::GetMax )
            , ( bp::arg("maxVal") ) )    
        .def( 
            "GetMin"
            , (bool ( ::ConVar::* )( float & ) const)( &::ConVar::GetMin )
            , ( bp::arg("minVal") ) )    
        .def( 
            "GetName"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetName ) )    
        .def( 
            "GetString"
            , (char const * ( ::ConVar::* )(  ) const)( &::ConVar::GetString ) )    
        .def( 
            "IsCommand"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::IsCommand ) )    
        .def( 
            "IsFlagSet"
            , (bool ( ::ConVar::* )( int ) const)( &::ConVar::IsFlagSet )
            , ( bp::arg("flag") ) )    
        .def( 
            "IsRegistered"
            , (bool ( ::ConVar::* )(  ) const)( &::ConVar::IsRegistered ) )    
        .def( 
            "Revert"
            , (void ( ::ConVar::* )(  ) )( &::ConVar::Revert ) );

    { //::PyGameEvent
        typedef bp::class_< PyGameEvent > GameEvent_exposer_t;
        GameEvent_exposer_t GameEvent_exposer = GameEvent_exposer_t( "GameEvent", bp::init< >() );
        bp::scope GameEvent_scope( GameEvent_exposer );
        GameEvent_exposer.def( bp::init< char const *, bp::optional< bool > >(( bp::arg("event_name"), bp::arg("force")=(bool)(false) )) );
        bp::implicitly_convertible< char const *, PyGameEvent >();
        { //::PyGameEvent::GetBool
        
            typedef bool ( ::PyGameEvent::*GetBool_function_type )( char const *,bool ) ;
            
            GameEvent_exposer.def( 
                "GetBool"
                , GetBool_function_type( &::PyGameEvent::GetBool )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=(bool)(false) ) );
        
        }
        { //::PyGameEvent::GetFloat
        
            typedef float ( ::PyGameEvent::*GetFloat_function_type )( char const *,float ) ;
            
            GameEvent_exposer.def( 
                "GetFloat"
                , GetFloat_function_type( &::PyGameEvent::GetFloat )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=0.0f ) );
        
        }
        { //::PyGameEvent::GetInt
        
            typedef int ( ::PyGameEvent::*GetInt_function_type )( char const *,int ) ;
            
            GameEvent_exposer.def( 
                "GetInt"
                , GetInt_function_type( &::PyGameEvent::GetInt )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")=(int)(0) ) );
        
        }
        { //::PyGameEvent::GetName
        
            typedef char const * ( ::PyGameEvent::*GetName_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "GetName"
                , GetName_function_type( &::PyGameEvent::GetName ) );
        
        }
        { //::PyGameEvent::GetString
        
            typedef char const * ( ::PyGameEvent::*GetString_function_type )( char const *,char const * ) ;
            
            GameEvent_exposer.def( 
                "GetString"
                , GetString_function_type( &::PyGameEvent::GetString )
                , ( bp::arg("keyName")=bp::object(), bp::arg("defaultValue")="" ) );
        
        }
        { //::PyGameEvent::IsEmpty
        
            typedef bool ( ::PyGameEvent::*IsEmpty_function_type )( char const * ) ;
            
            GameEvent_exposer.def( 
                "IsEmpty"
                , IsEmpty_function_type( &::PyGameEvent::IsEmpty )
                , ( bp::arg("keyName")=bp::object() ) );
        
        }
        { //::PyGameEvent::IsLocal
        
            typedef bool ( ::PyGameEvent::*IsLocal_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "IsLocal"
                , IsLocal_function_type( &::PyGameEvent::IsLocal ) );
        
        }
        { //::PyGameEvent::IsReliable
        
            typedef bool ( ::PyGameEvent::*IsReliable_function_type )(  ) const;
            
            GameEvent_exposer.def( 
                "IsReliable"
                , IsReliable_function_type( &::PyGameEvent::IsReliable ) );
        
        }
        { //::PyGameEvent::SetBool
        
            typedef void ( ::PyGameEvent::*SetBool_function_type )( char const *,bool ) ;
            
            GameEvent_exposer.def( 
                "SetBool"
                , SetBool_function_type( &::PyGameEvent::SetBool )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetFloat
        
            typedef void ( ::PyGameEvent::*SetFloat_function_type )( char const *,float ) ;
            
            GameEvent_exposer.def( 
                "SetFloat"
                , SetFloat_function_type( &::PyGameEvent::SetFloat )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetInt
        
            typedef void ( ::PyGameEvent::*SetInt_function_type )( char const *,int ) ;
            
            GameEvent_exposer.def( 
                "SetInt"
                , SetInt_function_type( &::PyGameEvent::SetInt )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
        { //::PyGameEvent::SetString
        
            typedef void ( ::PyGameEvent::*SetString_function_type )( char const *,char const * ) ;
            
            GameEvent_exposer.def( 
                "SetString"
                , SetString_function_type( &::PyGameEvent::SetString )
                , ( bp::arg("keyName"), bp::arg("value") ) );
        
        }
    }

    bp::class_< PyGameEventListener_wrapper >( "GameEventListener" )    
        .def( 
            "FireGameEvent"
            , (void ( ::PyGameEventListener::* )( ::boost::python::object ) )(&::PyGameEventListener::PyFireGameEvent)
            , (void ( PyGameEventListener_wrapper::* )( ::boost::python::object ) )(&PyGameEventListener_wrapper::default_FireGameEvent)
            , ( bp::arg("event") ) )    
        .def( "ListenForGameEvent", (void ( ::PyGameEventListener::* )( char const * ) )( &::PyGameEventListener::ListenForGameEvent ), bp::arg("name") )    
        .def( "StopListeningForAllEvents", (void ( ::PyGameEventListener::* )() )( &::PyGameEventListener::StopListeningForAllEvents ) );

    bp::class_< PyVEngineServer >( "VEngineServer" )    
        .def( 
            "AllowImmediateEdictReuse"
            , (void ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::AllowImmediateEdictReuse ) )    
        .def( 
            "ChangeLevel"
            , (void ( ::PyVEngineServer::* )( char const *,char const * ) )( &::PyVEngineServer::ChangeLevel )
            , ( bp::arg("s1"), bp::arg("s2")=bp::object() ) )    
        .def( 
            "ClearSaveDirAfterClientLoad"
            , (void ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::ClearSaveDirAfterClientLoad ) )    
        .def( 
            "ClientCommand"
            , (void ( ::PyVEngineServer::* )( ::CBasePlayer *,char const * ) )( &::PyVEngineServer::ClientCommand )
            , ( bp::arg("player"), bp::arg("command") ) )    
        .def( 
            "ClientPrintf"
            , (void ( ::PyVEngineServer::* )( ::CBasePlayer *,char const * ) )( &::PyVEngineServer::ClientPrintf )
            , ( bp::arg("player"), bp::arg("szMsg") ) )    
        .def( 
            "Con_NPrintf"
            , (void ( ::PyVEngineServer::* )( int,char const * ) )( &::PyVEngineServer::Con_NPrintf )
            , ( bp::arg("pos"), bp::arg("fmt") ) )    
        .def( 
            "EmitAmbientSound"
            , (void ( ::PyVEngineServer::* )( int,::Vector const &,char const *,float,::soundlevel_t,int,int,float ) )( &::PyVEngineServer::EmitAmbientSound )
            , ( bp::arg("entindex"), bp::arg("pos"), bp::arg("samp"), bp::arg("vol"), bp::arg("soundlevel"), bp::arg("fFlags"), bp::arg("pitch"), bp::arg("delay")=0.0f ) )    
        .def( 
            "FadeClientVolume"
            , (void ( ::PyVEngineServer::* )( ::CBasePlayer *,float,float,float,float ) )( &::PyVEngineServer::FadeClientVolume )
            , ( bp::arg("player"), bp::arg("fadePercent"), bp::arg("fadeOutSeconds"), bp::arg("holdTime"), bp::arg("fadeInSeconds") ) )    
        .def( 
            "ForceExactFile"
            , (void ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::ForceExactFile )
            , ( bp::arg("s") ) )    
        .def( 
            "ForceModelBounds"
            , (void ( ::PyVEngineServer::* )( char const *,::Vector const &,::Vector const & ) )( &::PyVEngineServer::ForceModelBounds )
            , ( bp::arg("s"), bp::arg("mins"), bp::arg("maxs") ) )    
        .def( 
            "ForceSimpleMaterial"
            , (void ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::ForceSimpleMaterial )
            , ( bp::arg("s") ) )    
        .def( 
            "GetAppID"
            , (int ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetAppID ) )    
        .def( 
            "GetClientConVarValue"
            , (char const * ( ::PyVEngineServer::* )( int,char const * ) )( &::PyVEngineServer::GetClientConVarValue )
            , ( bp::arg("clientIndex"), bp::arg("name") ) )    
        .def( 
            "GetClientSteamID"
            , (::boost::python::object ( ::PyVEngineServer::* )( ::CBasePlayer * ) )( &::PyVEngineServer::GetClientSteamID )
            , ( bp::arg("player") ) )    
        .def( 
            "GetEntityCount"
            , (int ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetEntityCount ) )    
        .def( 
            "GetGameDir"
            , (::boost::python::object ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetGameDir ) )    
        .def( 
            "GetMapEntitiesString"
            , (char const * ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetMapEntitiesString ) )    
        .def( 
            "GetMostRecentlyLoadedFileName"
            , (char const * ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetMostRecentlyLoadedFileName ) )    
        .def( 
            "GetPlayerInfo"
            , (bool ( ::PyVEngineServer::* )( int,::py_player_info_t * ) )( &::PyVEngineServer::GetPlayerInfo )
            , ( bp::arg("ent_num"), bp::arg("pinfo") ) )    
        .def( 
            "GetPlayerNetworkIDString"
            , (char const * ( ::PyVEngineServer::* )( ::CBasePlayer * ) )( &::PyVEngineServer::GetPlayerNetworkIDString )
            , ( bp::arg("player") ) )    
        .def( 
            "GetPlayerUserId"
            , (int ( ::PyVEngineServer::* )( ::CBasePlayer * ) )( &::PyVEngineServer::GetPlayerUserId )
            , ( bp::arg("player") ) )    
        .def( 
            "GetSaveFileName"
            , (char const * ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::GetSaveFileName ) )    
        .def( 
            "InsertServerCommand"
            , (void ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::InsertServerCommand )
            , ( bp::arg("str") ) )    
        .def( 
            "IsClientFullyAuthenticated"
            , (bool ( ::PyVEngineServer::* )( ::CBasePlayer * ) )( &::PyVEngineServer::IsClientFullyAuthenticated )
            , ( bp::arg("player") ) )    
        .def( 
            "IsDecalPrecached"
            , (bool ( ::PyVEngineServer::* )( char const * ) const)( &::PyVEngineServer::IsDecalPrecached )
            , ( bp::arg("s") ) )    
        .def( 
            "IsDedicatedServer"
            , (bool ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsDedicatedServer ) )    
        .def( 
            "IsGenericPrecached"
            , (bool ( ::PyVEngineServer::* )( char const * ) const)( &::PyVEngineServer::IsGenericPrecached )
            , ( bp::arg("s") ) )    
        .def( 
            "IsInCommentaryMode"
            , (int ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsInCommentaryMode ) )    
        .def( 
            "IsInEditMode"
            , (int ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsInEditMode ) )    
        .def( 
            "IsInternalBuild"
            , (bool ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsInternalBuild ) )    
        .def( 
            "IsLowViolence"
            , (bool ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsLowViolence ) )    
        .def( 
            "IsMapValid"
            , (int ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::IsMapValid )
            , ( bp::arg("filename") ) )    
        .def( 
            "IsModelPrecached"
            , (bool ( ::PyVEngineServer::* )( char const * ) const)( &::PyVEngineServer::IsModelPrecached )
            , ( bp::arg("s") ) )    
        .def( 
            "IsPaused"
            , (bool ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::IsPaused ) )    
        .def( 
            "LightStyle"
            , (void ( ::PyVEngineServer::* )( int,char const * ) )( &::PyVEngineServer::LightStyle )
            , ( bp::arg("style"), bp::arg("val") ) )    
        .def( 
            "LogPrint"
            , (void ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::LogPrint )
            , ( bp::arg("msg") ) )    
        .def( 
            "PrecacheDecal"
            , (int ( ::PyVEngineServer::* )( char const *,bool ) )( &::PyVEngineServer::PrecacheDecal )
            , ( bp::arg("name"), bp::arg("preload")=(bool)(false) ) )    
        .def( 
            "PrecacheGeneric"
            , (int ( ::PyVEngineServer::* )( char const *,bool ) )( &::PyVEngineServer::PrecacheGeneric )
            , ( bp::arg("s"), bp::arg("preload")=(bool)(false) ) )    
        .def( 
            "PrecacheModel"
            , (int ( ::PyVEngineServer::* )( char const *,bool ) )( &::PyVEngineServer::PrecacheModel )
            , ( bp::arg("s"), bp::arg("preload")=(bool)(false) ) )    
        .def( 
            "PrecacheSentenceFile"
            , (int ( ::PyVEngineServer::* )( char const *,bool ) )( &::PyVEngineServer::PrecacheSentenceFile )
            , ( bp::arg("s"), bp::arg("preload")=(bool)(false) ) )    
        .def( 
            "ServerCommand"
            , (void ( ::PyVEngineServer::* )( char const * ) )( &::PyVEngineServer::ServerCommand )
            , ( bp::arg("str") ) )    
        .def( 
            "ServerExecute"
            , (void ( ::PyVEngineServer::* )(  ) )( &::PyVEngineServer::ServerExecute ) )    
        .def( 
            "SetAreaPortalState"
            , (void ( ::PyVEngineServer::* )( int,int ) )( &::PyVEngineServer::SetAreaPortalState )
            , ( bp::arg("portalNumber"), bp::arg("isOpen") ) )    
        .def( 
            "SetDedicatedServerBenchmarkMode"
            , (void ( ::PyVEngineServer::* )( bool ) )( &::PyVEngineServer::SetDedicatedServerBenchmarkMode )
            , ( bp::arg("bBenchmarkMode") ) )    
        .def( 
            "StaticDecal"
            , (void ( ::PyVEngineServer::* )( ::Vector const &,int,int,int,bool ) )( &::PyVEngineServer::StaticDecal )
            , ( bp::arg("originInEntitySpace"), bp::arg("decalIndex"), bp::arg("entityIndex"), bp::arg("modelIndex"), bp::arg("lowpriority") ) );

    bp::class_< PyVModelInfo >( "VModelInfo" )    
        .def( 
            "FindOrLoadModel"
            , (::model_t * ( ::PyVModelInfo::* )( char const * ) )( &::PyVModelInfo::FindOrLoadModel )
            , ( bp::arg("name") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetModel"
            , (::model_t * ( ::PyVModelInfo::* )( int ) )( &::PyVModelInfo::GetModel )
            , ( bp::arg("modelindex") )
            , bp::return_value_policy< bp::return_by_value >() )    
        .def( 
            "GetModelBounds"
            , (::boost::python::tuple ( ::PyVModelInfo::* )( ::model_t * ) )( &::PyVModelInfo::GetModelBounds )
            , ( bp::arg("pModel") ) )    
        .def( 
            "GetModelIndex"
            , (int ( ::PyVModelInfo::* )( char const * ) )( &::PyVModelInfo::GetModelIndex )
            , ( bp::arg("name") ) )    
        .def( 
            "GetModelName"
            , (::boost::python::object ( ::PyVModelInfo::* )( ::model_t * ) )( &::PyVModelInfo::GetModelName )
            , ( bp::arg("model") ) );

    { //::dheader_t
        typedef bp::class_< dheader_t_wrapper > dheader_t_exposer_t;
        dheader_t_exposer_t dheader_t_exposer = dheader_t_exposer_t( "dheader_t" );
        bp::scope dheader_t_scope( dheader_t_exposer );
        dheader_t_exposer.def_readwrite( "ident", &dheader_t::ident );
        pyplusplus::containers::static_sized::register_array_1< ::lump_t, 64, bp::return_internal_reference< > >( "__array_1__scope_lump_t_64" );
        { //dheader_t::lumps [variable], type=lump_t[64]
        
            typedef pyplusplus::containers::static_sized::array_1_t< ::lump_t, 64> ( *array_wrapper_creator )( ::dheader_t & );
            
            dheader_t_exposer.add_property( "lumps"
                , bp::make_function( array_wrapper_creator(&dheader_t_wrapper::pyplusplus_lumps_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        dheader_t_exposer.def_readwrite( "mapRevision", &dheader_t::mapRevision );
        dheader_t_exposer.def_readwrite( "version", &dheader_t::version );
    }

    bp::class_< edict_t >( "edict_t" )    
        .def_readwrite( "freetime", &edict_t::freetime );

    { //::lump_t
        typedef bp::class_< lump_t_wrapper > lump_t_exposer_t;
        lump_t_exposer_t lump_t_exposer = lump_t_exposer_t( "lump_t" );
        bp::scope lump_t_scope( lump_t_exposer );
        lump_t_exposer.def_readwrite( "filelen", &lump_t::filelen );
        lump_t_exposer.def_readwrite( "fileofs", &lump_t::fileofs );
        pyplusplus::containers::static_sized::register_array_1< char, 4 >( "__array_1_char_4" );
        { //lump_t::fourCC [variable], type=char[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< char, 4> ( *array_wrapper_creator )( ::lump_t & );
            
            lump_t_exposer.add_property( "fourCC"
                , bp::make_function( array_wrapper_creator(&lump_t_wrapper::pyplusplus_fourCC_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        lump_t_exposer.def_readwrite( "version", &lump_t::version );
    }

    { //::py_player_info_s
        typedef bp::class_< py_player_info_s_wrapper > PlayerInfo_exposer_t;
        PlayerInfo_exposer_t PlayerInfo_exposer = PlayerInfo_exposer_t( "PlayerInfo" );
        bp::scope PlayerInfo_scope( PlayerInfo_exposer );
        pyplusplus::containers::static_sized::register_array_1< unsigned int, 4 >( "__array_1_unsigned_int_4" );
        { //py_player_info_s::customFiles [variable], type=CRC32_t[4]
        
            typedef pyplusplus::containers::static_sized::array_1_t< unsigned int, 4> ( *array_wrapper_creator )( ::py_player_info_s & );
            
            PlayerInfo_exposer.add_property( "customFiles"
                , bp::make_function( array_wrapper_creator(&py_player_info_s_wrapper::pyplusplus_customFiles_wrapper)
                                    , bp::with_custodian_and_ward_postcall< 0, 1 >() ) );
        }
        PlayerInfo_exposer.def_readwrite( "fakeplayer", &py_player_info_s::fakeplayer );
        PlayerInfo_exposer.def_readwrite( "filesDownloaded", &py_player_info_s::filesDownloaded );
        PlayerInfo_exposer.def_readwrite( "friendsID", &py_player_info_s::friendsID );
        PlayerInfo_exposer.def_readwrite( "friendsName", &py_player_info_s::friendsName );
        PlayerInfo_exposer.def_readwrite( "guid", &py_player_info_s::guid );
        PlayerInfo_exposer.def_readwrite( "ishltv", &py_player_info_s::ishltv );
        PlayerInfo_exposer.def_readwrite( "name", &py_player_info_s::name );
        PlayerInfo_exposer.def_readwrite( "userID", &py_player_info_s::userID );
    }

    bp::class_< wrap_model_t >( "model_t", bp::no_init );

    { //::CommandLine_Tier0
    
        typedef ::ICommandLine * ( *CommandLine_function_type )(  );
        
        bp::def( 
            "CommandLine"
            , CommandLine_function_type( &::CommandLine_Tier0 )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::GetLevelName
    
        typedef char const * ( *GetLevelName_function_type )(  );
        
        bp::def( 
            "GetLevelName"
            , GetLevelName_function_type( &::GetLevelName ) );
    
    }

    { //::Plat_FloatTime
    
        typedef double ( *Plat_FloatTime_function_type )(  );
        
        bp::def( 
            "Plat_FloatTime"
            , Plat_FloatTime_function_type( &::Plat_FloatTime ) );
    
    }

    { //::Plat_MSTime
    
        typedef unsigned int ( *Plat_MSTime_function_type )(  );
        
        bp::def( 
            "Plat_MSTime"
            , Plat_MSTime_function_type( &::Plat_MSTime ) );
    
    }

    { //::PrecacheMaterial
    
        typedef void ( *PrecacheMaterial_function_type )( char const * );
        
        bp::def( 
            "PrecacheMaterial"
            , PrecacheMaterial_function_type( &::PrecacheMaterial )
            , ( bp::arg("pMaterialName") ) );
    
    }

    { //::PyAddSearchPath
    
        typedef void ( *AddSearchPath_function_type )( char const *,char const *,::SearchPathAdd_t );
        
        bp::def( 
            "AddSearchPath"
            , AddSearchPath_function_type( &::PyAddSearchPath )
            , ( bp::arg("pPath"), bp::arg("pathID"), bp::arg("addType")=::PATH_ADD_TO_TAIL ) );
    
    }

    { //::PyAsyncFinishAllWrites
    
        typedef void ( *AsyncFinishAllWrites_function_type )(  );
        
        bp::def( 
            "AsyncFinishAllWrites"
            , AsyncFinishAllWrites_function_type( &::PyAsyncFinishAllWrites ) );
    
    }

    { //::PyFireGameEvent
    
        typedef void ( *FireGameEvent_function_type )( ::PyGameEvent *,bool );
        
        bp::def( 
            "FireGameEvent"
            , FireGameEvent_function_type( &::PyFireGameEvent )
            , ( bp::arg("pEvent"), bp::arg("bDontBroadcast")=(bool)(false) ) );
    
    }

    { //::PyGetMapEntityRef
    
        typedef ::CMapEntityRef ( *GetMapEntityRef_function_type )( int );
        
        bp::def( 
            "GetMapEntityRef"
            , GetMapEntityRef_function_type( &::PyGetMapEntityRef )
            , ( bp::arg("it") ) );
    
    }

    { //::PyGetMapEntityRefIteratorHead
    
        typedef int ( *GetMapEntityRefIteratorHead_function_type )(  );
        
        bp::def( 
            "GetMapEntityRefIteratorHead"
            , GetMapEntityRefIteratorHead_function_type( &::PyGetMapEntityRefIteratorHead ) );
    
    }

    { //::PyGetMapEntityRefIteratorNext
    
        typedef int ( *GetMapEntityRefIteratorNext_function_type )( int );
        
        bp::def( 
            "GetMapEntityRefIteratorNext"
            , GetMapEntityRefIteratorNext_function_type( &::PyGetMapEntityRefIteratorNext )
            , ( bp::arg("it") ) );
    
    }

    { //::PyGetMapHeader
    
        typedef ::dheader_t ( *GetMapHeader_function_type )( char const * );
        
        bp::def( 
            "GetMapHeader"
            , GetMapHeader_function_type( &::PyGetMapHeader )
            , ( bp::arg("mapname") ) );
    
    }

    { //::PyGetModPath
    
        typedef ::boost::python::object ( *GetModPath_function_type )(  );
        
        bp::def( 
            "GetModPath"
            , GetModPath_function_type( &::PyGetModPath ) );
    
    }

    { //::PyGetSearchPath
    
        typedef ::boost::python::object ( *GetSearchPath_function_type )( char const *,bool );
        
        bp::def( 
            "GetSearchPath"
            , GetSearchPath_function_type( &::PyGetSearchPath )
            , ( bp::arg("pPathID"), bp::arg("bGetPackFiles") ) );
    
    }

    { //::PyMapEntity_ParseAllEntities
    
        typedef void ( *MapEntity_ParseAllEntities_function_type )( char const *,::IMapEntityFilter *,bool );
        
        bp::def( 
            "MapEntity_ParseAllEntities"
            , MapEntity_ParseAllEntities_function_type( &::PyMapEntity_ParseAllEntities )
            , ( bp::arg("mapdata"), bp::arg("filter"), bp::arg("activateentities") ) );
    
    }

    { //::PyRemoveSearchPath
    
        typedef bool ( *RemoveSearchPath_function_type )( char const *,char const * );
        
        bp::def( 
            "RemoveSearchPath"
            , RemoveSearchPath_function_type( &::PyRemoveSearchPath )
            , ( bp::arg("pPath"), bp::arg("pathID")=bp::object() ) );
    
    }

    { //::PySendUserMessage
    
        typedef void ( *SendUserMessage_function_type )( ::IRecipientFilter &,char const *,::boost::python::list );
        
        bp::def( 
            "SendUserMessage"
            , SendUserMessage_function_type( &::PySendUserMessage )
            , ( bp::arg("filter"), bp::arg("messagename"), bp::arg("msg") ) );
    
    }

    { //::PyShutdownConCommand
    
        typedef bool ( *PyShutdownConCommand_function_type )( char const * );
        
        bp::def( 
            "PyShutdownConCommand"
            , PyShutdownConCommand_function_type( &::PyShutdownConCommand )
            , ( bp::arg("pName") ) );
    
    }

    bp::scope().attr( "engine" ) = boost::ref(pyengine);

    bp::scope().attr( "modelinfo" ) = boost::ref(pymodelinfo);

    ptr_model_t_to_wrap_model_t();

    const_ptr_model_t_to_wrap_model_t();

    wrap_model_t_to_model_t();

    bp::scope().attr( "LUMP_ENTITIES" ) = (int)LUMP_ENTITIES;

    bp::scope().attr( "FCVAR_NONE" ) = (int)FCVAR_NONE;

    bp::scope().attr( "FCVAR_UNREGISTERED" ) = (int)FCVAR_UNREGISTERED;

    bp::scope().attr( "FCVAR_DEVELOPMENTONLY" ) = (int)FCVAR_DEVELOPMENTONLY;

    bp::scope().attr( "FCVAR_GAMEDLL" ) = (int)FCVAR_GAMEDLL;

    bp::scope().attr( "FCVAR_CLIENTDLL" ) = (int)FCVAR_CLIENTDLL;

    bp::scope().attr( "FCVAR_HIDDEN" ) = (int)FCVAR_HIDDEN;

    bp::scope().attr( "FCVAR_PROTECTED" ) = (int)FCVAR_PROTECTED;

    bp::scope().attr( "FCVAR_SPONLY" ) = (int)FCVAR_SPONLY;

    bp::scope().attr( "FCVAR_ARCHIVE" ) = (int)FCVAR_ARCHIVE;

    bp::scope().attr( "FCVAR_NOTIFY" ) = (int)FCVAR_NOTIFY;

    bp::scope().attr( "FCVAR_USERINFO" ) = (int)FCVAR_USERINFO;

    bp::scope().attr( "FCVAR_CHEAT" ) = (int)FCVAR_CHEAT;

    bp::scope().attr( "FCVAR_PRINTABLEONLY" ) = (int)FCVAR_PRINTABLEONLY;

    bp::scope().attr( "FCVAR_UNLOGGED" ) = (int)FCVAR_UNLOGGED;

    bp::scope().attr( "FCVAR_NEVER_AS_STRING" ) = (int)FCVAR_NEVER_AS_STRING;

    bp::scope().attr( "FCVAR_REPLICATED" ) = (int)FCVAR_REPLICATED;

    bp::scope().attr( "FCVAR_DEMO" ) = (int)FCVAR_DEMO;

    bp::scope().attr( "FCVAR_DONTRECORD" ) = (int)FCVAR_DONTRECORD;

    bp::scope().attr( "FCVAR_NOT_CONNECTED" ) = (int)FCVAR_NOT_CONNECTED;

    bp::scope().attr( "FCVAR_ARCHIVE_XBOX" ) = (int)FCVAR_ARCHIVE_XBOX;

    bp::scope().attr( "FCVAR_SERVER_CAN_EXECUTE" ) = (int)FCVAR_SERVER_CAN_EXECUTE;

    bp::scope().attr( "FCVAR_SERVER_CANNOT_QUERY" ) = (int)FCVAR_SERVER_CANNOT_QUERY;

    bp::scope().attr( "FCVAR_CLIENTCMD_CAN_EXECUTE" ) = (int)FCVAR_CLIENTCMD_CAN_EXECUTE;

    { //::PyShutdownConVar
    
        typedef bool ( *PyShutdownConVar_function_type )( char const * );
        
        bp::def( 
            "PyShutdownConVar"
            , PyShutdownConVar_function_type( &::PyShutdownConVar )
            , ( bp::arg("pName") ) );
    
    }
}
#endif

